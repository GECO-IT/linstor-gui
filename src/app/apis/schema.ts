/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/v1/storage-pool-definitions': {
    /** Returns an array of all storage pool definitions */
    get: operations['storagePoolDfnList'];
    /** Adds a storage pool definition to Linstor */
    post: operations['storagePoolDfnAdd'];
  };
  '/v1/storage-pool-definitions/{storagepool}': {
    /** Returns a specific storage pool definition */
    get: operations['storagePoolDfnGet'];
    /**
     * Sets or modifies properties
     *
     * Possible properties are:
     * - `MaxOversubscriptionRatio` - range[`1-1000`]
     */
    put: operations['storPoolDfnModify'];
    /** Delete a storage pool definition from Linstor */
    delete: operations['storagePoolDefinitionDelete'];
  };
  '/v1/storage-pool-definitions/properties/info': {
    /**
     * List all properties, including their names and descriptions, that can
     * be set for any given storage pool definition.
     */
    get: {
      responses: {
        /**
         * A map where the key is the property name and the value is a
         * PropsInfo object describing the property.
         */
        200: {
          content: {
            'application/json': {
              [key: string]: components['schemas']['PropsInfo'];
            };
          };
        };
      };
    };
  };
  '/v1/nodes': {
    /** Returns an array of all nodes registered to Linstor. */
    get: operations['nodeList'];
    /**
     * Adds a node to Linstor
     *
     * If only one net-interface is specified and it is does not specify
     * a `satellite_port` it will apply the default port and `satellite_encryption_type`
     * for this net-interface.
     */
    post: operations['nodeAdd'];
  };
  '/v1/stats/nodes': {
    /** Returns a node stats object. */
    get: operations['nodeStats'];
  };
  '/v1/nodes/{node}': {
    /**
     * Sets or modifies properties
     *
     * Possible properties are:
     * - `PrefNic` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Preferred network interface to use
     *
     * - `StorPoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Linstor storage pool name to use.
     *
     * - `StorPoolNameDrbdMeta` - regex[`^|.internal|[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Linstor storage pool name to use for external metadata.
     *
     * - `sys/fs/blkio_throttle_read` - long
     *
     *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device
     *
     * - `sys/fs/blkio_throttle_write` - long
     *
     *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device
     *
     * - `sys/fs/blkio_throttle_read_iops` - long
     *
     *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_iops_device
     *
     * - `sys/fs/blkio_throttle_write_iops` - long
     *
     *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_iops_device
     *
     * - `DrbdOptions/AutoEvictAfterTime` - long
     *
     *     Time a node can be offline before it is declared EVICTED in minutes
     *
     * - `DrbdOptions/AutoEvictAllowEviction` - boolean_true_false
     *
     *     If set to true on a node, it cannot be evicted anymore
     *
     * - `Writecache/PoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Linstor storage pool name for writecache
     *
     * - `Writecache/Size` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
     *
     *     Size of the writecache in % (0-100) or KiB otherwise
     *
     * - `Writecache/Options/StartSector` - long
     *
     *     offset from the start of cache device in 512-byte sectors
     *
     * - `Writecache/Options/HighWatermark` - long
     *
     *     start writeback when the number of used blocks reach this watermark
     *
     * - `Writecache/Options/LowWatermark` - long
     *
     *     stop writeback when the number of used blocks drops below this watermark
     *
     * - `Writecache/Options/WritebackJobs` - long
     *
     *     limit the number of blocks that are in flight during writeback. Setting this value reduces writeback throughput, but it may improve latency of read requests
     *
     * - `Writecache/Options/AutocommitBlocks` - long
     *
     *     when the application writes this amount of blocks without issuing the FLUSH request, the blocks are automatically commited
     *
     * - `Writecache/Options/AutocommitTime` - long
     *
     *     autocommit time in milliseconds. The data is automatically commited if this time passes and no FLUSH request is received
     *
     * - `Writecache/Options/Fua` - enum
     *
     *     "On" results in "fua" as argument, whereas the value "Off" results in "nofua" argument
     *
     *     * On
     *     * Off
     *
     * - `Writecache/Options/Additional` - string
     *
     *     Additional arguments passed through
     *
     * - `Cache/OpMode` - enum
     *
     *     Operation mode
     *
     *     * writeback
     *     * writethrough
     *     * passthrough
     *
     * - `Cache/MetaPool` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Name of the storage pool used for the cache metadata. If not specified, this will default to the CachePool property
     *
     * - `Cache/Metasize` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
     *
     *     Size of the cache in % (0-100) or KiB otherwise.
     *
     * - `Cache/CachePool` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Name of the storage pool used for the cache cache device
     *
     * - `Cache/Cachesize` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
     *
     *     Size of the cache in % (0-100) or KiB otherwise.
     *
     * - `Cache/Blocksize` - long
     *
     *     Block size
     *
     * - `Cache/Policy` - enum
     *
     *     Replacemant policy
     *
     *     * mq
     *     * smq
     *     * cleaner
     *
     * - `StorDriver/LvcreateOptions` - regex[`.*`]
     *
     *     Additional parameters added to every 'lvcreate ... ' command
     *
     * - `StorDriver/ZfscreateOptions` - regex[`.*`]
     *
     *     Additional parameters added to every 'zfs create ... ' command
     *
     * - `StorDriver/Openflex/ApiHost` - regex[`.+`]
     *
     *     Openflex API host name
     *
     * - `StorDriver/Openflex/ApiPort` - regex[`[0-9]+`]
     *
     *     Openflex API port
     *
     * - `StorDriver/Openflex/UserName` - regex[`.+`]
     *
     *     Openflex user name
     *
     * - `StorDriver/Openflex/UserPassword` - regex[`.+`]
     *
     *     Openflex password
     *
     * - `StorDriver/Openflex/StorDev` - regex[`.+`]
     *
     *     Openflex storage device
     *
     * - `StorDriver/Openflex/StorDevHost` - regex[`.+`]
     *
     *     Openflex storage device host
     *
     * - `StorDriver/Openflex/JobWaitDelay` - regex[`[0-9]+`]
     *
     *     Delay in milliseconds linstor waits between fetching the job status
     *
     * - `StorDriver/Openflex/JobWaitMaxCount` - regex[`[0-9]+`]
     *
     *     Maximum retries with wait delay until openflex fails
     *
     * - `Autoplacer/MaxThroughput` - long
     *
     *     The maximum throughput the given storage pool is capable of.
     *
     * - `DrbdProxy/AutoEnable` - boolean_true_false
     * - `Site` - string
     * - `DrbdOptions/auto-diskful-allow-cleanup` - boolean_true_false
     *
     *     Allows this resource to be cleaned up after toggle-disk + resync is finished
     */
    put: operations['nodeModify'];
    /** Delete a node from Linstor */
    delete: operations['nodeDelete'];
  };
  '/v1/nodes/properties/info': {
    /**
     * List all properties, including their names and descriptions, that can
     * be set for any given node.
     */
    get: {
      responses: {
        /**
         * A map where the key is the property name and the value is a
         * PropsInfo object describing the property.
         */
        200: {
          content: {
            'application/json': {
              [key: string]: components['schemas']['PropsInfo'];
            };
          };
        };
      };
    };
  };
  '/v1/nodes/{node}/lost': {
    /** Delete an unrecoverable node */
    delete: operations['nodeLost'];
  };
  '/v1/nodes/{node}/reconnect': {
    /** Reconnect a node to the controller */
    put: operations['nodeReconnect'];
  };
  '/v1/nodes/{node}/net-interfaces': {
    /** Returns the list of netinterfaces for this node */
    get: operations['netinterfaceList'];
    /**
     * Create a netinterface on a node
     *
     * If satellite_port and satellite_encryption_type are given
     * the netinterface can also work as connection to the controller
     */
    post: operations['netinterfaceCreate'];
  };
  '/v1/nodes/{node}/net-interfaces/{netinterface}': {
    /** Modify a netinterface from a node */
    put: operations['netinterfaceModified'];
    /** Delete a netinterface from a node */
    delete: operations['netinterfaceDelete'];
  };
  '/v1/nodes/{node}/storage-pools': {
    /** Lists all storage pools of a node */
    get: operations['nodeStoragePoolList'];
    /**
     * Creates a new storage pool on this node.
     *
     * `provider_kind` has to be specified and additional to that
     * the linked `StorDriver` property that has the value to the backing pool:
     *
     *   * `LVM`: `StorDriver/LvmVg`
     *   * `LVM_THIN`: `StorDriver/LvmVg` and `StorDriver/ThinPool`
     *   * `ZFS`: `StorDriver/ZPool`
     *   * `ZFS_THIN`: `StorDriver/ZPoolThin`
     *   * `DISKLESS`: Does not need a property as it has no backing pool
     */
    post: operations['nodeStoragePoolCreate'];
  };
  '/v1/nodes/{node}/storage-pools/{storagepool}': {
    /**
     * Sets or modifies properties
     *
     * Possible properties are:
     * - `StorDriver/StorPoolName` - regex[`[a-zA-Z0-9_/-]+`]
     * - `StorDriver/LvmVg` - regex[`[a-zA-Z0-9_-]+`]
     * - `StorDriver/ThinPool` - regex[`[a-zA-Z0-9_-]+`]
     * - `StorDriver/ZPool` - regex[`[a-zA-Z0-9_/-]+`]
     * - `StorDriver/ZPoolThin` - regex[`[a-zA-Z0-9_/-]+`]
     * - `StorDriver/FileDir` - regex[`.*`]
     * - `PrefNic` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Preferred network interface to use
     *
     * - `NVMe/PrefNic` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Preferred network interface to use
     *
     * - `StorDriver/LvcreateType` - enum
     *     * linear
     *     * striped
     *     * mirror
     *     * raid0
     *     * raid1
     *     * raid4
     *     * raid5
     *     * raid6
     *     * raid10
     *     * lzma
     *     * lz4
     *
     * - `StorDriver/LvcreateOptions` - regex[`.*`]
     *
     *     Additional parameters added to every 'lvcreate ... ' command
     *
     * - `StorDriver/ZfscreateOptions` - regex[`.*`]
     *
     *     Additional parameters added to every 'zfs create ... ' command
     *
     * - `StorDriver/WaitTimeoutAfterCreate` - regex[`[0-9]+`]
     * - `sys/fs/blkio_throttle_read` - long
     *
     *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device
     *
     * - `sys/fs/blkio_throttle_write` - long
     *
     *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device
     *
     * - `sys/fs/blkio_throttle_read_iops` - long
     *
     *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_iops_device
     *
     * - `sys/fs/blkio_throttle_write_iops` - long
     *
     *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_iops_device
     *
     * - `StorDriver/Openflex/ApiHost` - regex[`.+`]
     *
     *     Openflex API host name
     *
     * - `StorDriver/Openflex/ApiPort` - regex[`[0-9]+`]
     *
     *     Openflex API port
     *
     * - `StorDriver/Openflex/UserName` - regex[`.+`]
     *
     *     Openflex user name
     *
     * - `StorDriver/Openflex/UserPassword` - regex[`.+`]
     *
     *     Openflex password
     *
     * - `StorDriver/Openflex/StorDev` - regex[`.+`]
     *
     *     Openflex storage device
     *
     * - `StorDriver/Openflex/StorDevHost` - regex[`.+`]
     *
     *     Openflex storage device host
     *
     * - `StorDriver/Openflex/StorPool` - regex[`[0-9]+`]
     *
     *     Openflex storage pool name
     *
     * - `Autoplacer/MaxThroughput` - long
     *
     *     The maximum throughput the given storage pool is capable of.
     */
    put: operations['nodeStoragePoolModify'];
    /** Delete a storage pool */
    delete: operations['nodeStoragePoolDelete'];
  };
  '/v1/nodes/{node}/storage-pools/properties/info': {
    /**
     * List all properties, including their names and descriptions, that can
     * be set for any given storage pool on a particular node.
     */
    get: {
      parameters: {
        path: {
          /** node to use */
          node: string;
        };
      };
      responses: {
        /**
         * A map where the key is the property name and the value is a
         * PropsInfo object describing the property.
         */
        200: {
          content: {
            'application/json': {
              [key: string]: components['schemas']['PropsInfo'];
            };
          };
        };
      };
    };
  };
  '/v1/nodes/{node}/restore': {
    /** restore an evicted node */
    put: {
      parameters: {
        path: {
          /** node to use */
          node: string;
        };
      };
      responses: {
        /** node restored */
        200: {
          content: {
            'application/json': components['schemas']['ApiCallRcList'];
          };
        };
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['NodeRestore'];
        };
      };
    };
  };
  '/v1/nodes/{node}/config': {
    /** Show Satellite config */
    get: operations['SatelliteConfig'];
    put: operations['StltSetConfig'];
  };
  '/v1/nodes/{node}/evacuate': {
    /**
     * Evacuates DRBD resources from the given node to other available nodes
     * and deletes the evacuated resources once the sync is complete. Additionally
     * sets the Node into EVACUATE state (no new resources allowed)
     */
    put: operations['nodeEvacuate'];
  };
  '/v1/nodes/ebs': {
    /** Adds an EBS node to Linstor */
    post: operations['nodeAddEbs'];
  };
  '/v1/resource-definitions': {
    /**
     * Lists all resource definitions.
     *
     * A single resource definition can be queried by adding its name
     * to the resource string like:
     *
     * /v1/resource-definitions/rsc1
     */
    get: operations['resourceDefinitionList'];
    /**
     * Adds a resource-definition.
     *
     * Only required property is the name of the resource definition.
     * All other properties are optional.
     */
    post: operations['resourceDefinitionCreate'];
  };
  '/v1/stats/resource-definitions': {
    /** Returns a resource definition stats object. */
    get: operations['resourceDefinitionStats'];
  };
  '/v1/resource-definitions/{resource}': {
    /**
     * Sets or modifies properties
     *
     * Possible properties are:
     * - `StorPoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Linstor storage pool name to use.
     *
     * - `StorPoolNameDrbdMeta` - regex[`^|.internal|[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Linstor storage pool name to use for external metadata.
     *
     * - `PeerSlotsNewResource` - range[`1-31`]
     *
     *     DRBD peer slots to allocate for newly created resources (default 7), the number of peer slots cannot be changed once the resource is created, so allow sufficient slots to increase redundancy in the future
     *
     * - `DrbdProxy/CompressionType` - enum
     *     * zlib
     *     * lzma
     *     * lz4
     *     * zstd
     *
     * - `DrbdOptions/AutoEvictMinReplicaCount` - long
     *
     *     The minimum amount of replicas that should be present for a resource at all times.
     *
     * - `FileSystem/Type` - enum
     *
     *     File system type to use
     *
     *     * ext4
     *     * xfs
     *
     * - `FileSystem/MkfsParams` - string
     *
     *     Additional parameters for the mkfs command
     *
     * - `NVMe/TRType` - enum
     *
     *     NVMe transportion type
     *
     *     * rdma
     *     * tcp
     *
     * - `NVMe/Port` - range[`1-65535`]
     *
     *     NVMe port
     *
     * - `StorDriver/LvcreateType` - enum
     *     * linear
     *     * striped
     *     * mirror
     *     * raid0
     *     * raid1
     *     * raid4
     *     * raid5
     *     * raid6
     *     * raid10
     *     * lzma
     *     * lz4
     *
     * - `StorDriver/LvcreateOptions` - regex[`.*`]
     *
     *     Additional parameters added to every 'lvcreate ... ' command
     *
     * - `StorDriver/ZfscreateOptions` - regex[`.*`]
     *
     *     Additional parameters added to every 'zfs create ... ' command
     *
     * - `sys/fs/blkio_throttle_read` - long
     *
     *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device
     *
     * - `sys/fs/blkio_throttle_write` - long
     *
     *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device
     *
     * - `sys/fs/blkio_throttle_read_iops` - long
     *
     *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_iops_device
     *
     * - `sys/fs/blkio_throttle_write_iops` - long
     *
     *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_iops_device
     *
     * - `DrbdOptions/auto-quorum` - enum
     *
     *     Enables automatic setting of the 'quroum' and 'on-no-quroum' property
     *
     *     * io-error
     *     * suspend-io
     *     * disabled
     *
     * - `DrbdOptions/auto-add-quorum-tiebreaker` - boolean_true_false
     *
     *     Enables automatic management (creation and deletion) of tie breaking resource
     *
     * - `DrbdOptions/auto-diskful` - long
     *
     *     Makes a resource diskful if it was continously diskless primary for X minutes
     *
     * - `DrbdOptions/auto-diskful-allow-cleanup` - boolean_true_false
     *
     *     Allows this resource to be cleaned up after toggle-disk + resync is finished
     *
     * - `Writecache/PoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Linstor storage pool name for writecache
     *
     * - `Writecache/Size` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
     *
     *     Size of the writecache in % (0-100) or KiB otherwise
     *
     * - `Writecache/Options/StartSector` - long
     *
     *     offset from the start of cache device in 512-byte sectors
     *
     * - `Writecache/Options/HighWatermark` - long
     *
     *     start writeback when the number of used blocks reach this watermark
     *
     * - `Writecache/Options/LowWatermark` - long
     *
     *     stop writeback when the number of used blocks drops below this watermark
     *
     * - `Writecache/Options/WritebackJobs` - long
     *
     *     limit the number of blocks that are in flight during writeback. Setting this value reduces writeback throughput, but it may improve latency of read requests
     *
     * - `Writecache/Options/AutocommitBlocks` - long
     *
     *     when the application writes this amount of blocks without issuing the FLUSH request, the blocks are automatically commited
     *
     * - `Writecache/Options/AutocommitTime` - long
     *
     *     autocommit time in milliseconds. The data is automatically commited if this time passes and no FLUSH request is received
     *
     * - `Writecache/Options/Fua` - enum
     *
     *     "On" results in "fua" as argument, whereas the value "Off" results in "nofua" argument
     *
     *     * On
     *     * Off
     *
     * - `Writecache/Options/Additional` - string
     *
     *     Additional arguments passed through
     *
     * - `Cache/OpMode` - enum
     *
     *     Operation mode
     *
     *     * writeback
     *     * writethrough
     *     * passthrough
     *
     * - `Cache/MetaPool` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Name of the storage pool used for the cache metadata. If not specified, this will default to the CachePool property
     *
     * - `Cache/Metasize` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
     *
     *     Size of the cache in % (0-100) or KiB otherwise.
     *
     * - `Cache/CachePool` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Name of the storage pool used for the cache cache device
     *
     * - `Cache/Cachesize` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
     *
     *     Size of the cache in % (0-100) or KiB otherwise.
     *
     * - `Cache/Blocksize` - long
     *
     *     Block size
     *
     * - `Cache/Policy` - enum
     *
     *     Replacemant policy
     *
     *     * mq
     *     * smq
     *     * cleaner
     *
     * - `SnapshotShipping/SourceNode` - string
     *
     *     Node name of the snapshot shipping source
     *
     * - `SnapshotShipping/TargetNode` - string
     *
     *     Node name of the snapshot shipping target
     *
     * - `SnapshotShipping/RunEvery` - long
     *
     *     Runs every X minutes an auto-snapshot-shipping unless the current snapshot-shipping is still running. In this case a new one will be started asap.
     *
     * - `SnapshotShipping/Keep` - long
     *
     *     Keeps the last X sihpped snapshots. Removing this property or having a value <= 0 disables auto-cleanup, all auto-snapshots will be kept
     *
     * - `AutoSnapshot/RunEvery` - long
     *
     *     Runs every X minutes an snapshot-creation. Removing this property or having a value <= 0 disables auto-snapshotting.
     *
     * - `AutoSnapshot/Keep` - long
     *
     *     Keeps the last X auto-snapshots. Removing this property or having a value <= 0 disables auto-cleanup, all auto-snapshots will be kept
     *
     * - `AutoSnapshot/NextAutoId` - long
     *
     *     The next ID to try for auto-snapshots
     *
     * - `DrbdOptions/Disk/on-io-error` - enum
     *     * pass_on
     *     * call-local-io-error
     *     * detach
     *
     * - `DrbdOptions/Disk/disk-barrier` - boolean
     * - `DrbdOptions/Disk/disk-flushes` - boolean
     * - `DrbdOptions/Disk/disk-drain` - boolean
     * - `DrbdOptions/Disk/md-flushes` - boolean
     * - `DrbdOptions/Disk/resync-after` - string
     * - `DrbdOptions/Disk/al-extents` - range[`67-65534`]
     * - `DrbdOptions/Disk/al-updates` - boolean
     * - `DrbdOptions/Disk/discard-zeroes-if-aligned` - boolean
     * - `DrbdOptions/Disk/disable-write-same` - boolean
     * - `DrbdOptions/Disk/disk-timeout` - range[`0-6000`]
     * - `DrbdOptions/Disk/read-balancing` - enum
     *     * prefer-local
     *     * prefer-remote
     *     * round-robin
     *     * least-pending
     *     * when-congested-remote
     *     * 32K-striping
     *     * 64K-striping
     *     * 128K-striping
     *     * 256K-striping
     *     * 512K-striping
     *     * 1M-striping
     *
     * - `DrbdOptions/Disk/rs-discard-granularity` - range[`0-1048576`]
     * - `DrbdOptions/PeerDevice/resync-rate` - range[`1-8388608`]
     * - `DrbdOptions/PeerDevice/c-plan-ahead` - range[`0-300`]
     * - `DrbdOptions/PeerDevice/c-delay-target` - range[`1-100`]
     * - `DrbdOptions/PeerDevice/c-fill-target` - range[`0-1048576`]
     * - `DrbdOptions/PeerDevice/c-max-rate` - range[`250-4194304`]
     * - `DrbdOptions/PeerDevice/c-min-rate` - range[`0-4194304`]
     * - `DrbdOptions/PeerDevice/bitmap` - boolean
     * - `DrbdOptions/Resource/cpu-mask` - string
     * - `DrbdOptions/Resource/on-no-data-accessible` - enum
     *     * io-error
     *     * suspend-io
     *
     * - `DrbdOptions/Resource/auto-promote` - boolean
     * - `DrbdOptions/Resource/peer-ack-window` - range[`2048-204800`]
     * - `DrbdOptions/Resource/peer-ack-delay` - range[`1-10000`]
     * - `DrbdOptions/Resource/twopc-timeout` - range[`50-600`]
     * - `DrbdOptions/Resource/twopc-retry-timeout` - range[`1-50`]
     * - `DrbdOptions/Resource/auto-promote-timeout` - range[`0-600`]
     * - `DrbdOptions/Resource/max-io-depth` - range[`4-4294967295`]
     * - `DrbdOptions/Resource/quorum` - enum [`1-32`]
     *     * off
     *     * majority
     *     * all
     *
     * - `DrbdOptions/Resource/on-no-quorum` - enum
     *     * io-error
     *     * suspend-io
     *
     * - `DrbdOptions/Resource/quorum-minimum-redundancy` - enum [`1-32`]
     *     * off
     *     * majority
     *     * all
     *
     * - `DrbdOptions/Net/transport` - string
     * - `DrbdOptions/Net/protocol` - enum
     *     * A
     *     * B
     *     * C
     *
     * - `DrbdOptions/Net/timeout` - range[`1-600`]
     * - `DrbdOptions/Net/max-epoch-size` - range[`1-20000`]
     * - `DrbdOptions/Net/connect-int` - range[`1-120`]
     * - `DrbdOptions/Net/ping-int` - range[`1-120`]
     * - `DrbdOptions/Net/sndbuf-size` - range[`0-10485760`]
     * - `DrbdOptions/Net/rcvbuf-size` - range[`0-10485760`]
     * - `DrbdOptions/Net/ko-count` - range[`0-200`]
     * - `DrbdOptions/Net/allow-two-primaries` - boolean
     * - `DrbdOptions/Net/cram-hmac-alg` - string
     * - `DrbdOptions/Net/shared-secret` - string
     * - `DrbdOptions/Net/after-sb-0pri` - enum
     *     * disconnect
     *     * discard-younger-primary
     *     * discard-older-primary
     *     * discard-zero-changes
     *     * discard-least-changes
     *     * discard-local
     *     * discard-remote
     *
     * - `DrbdOptions/Net/after-sb-1pri` - enum
     *     * disconnect
     *     * consensus
     *     * discard-secondary
     *     * call-pri-lost-after-sb
     *     * violently-as0p
     *
     * - `DrbdOptions/Net/after-sb-2pri` - enum
     *     * disconnect
     *     * call-pri-lost-after-sb
     *     * violently-as0p
     *
     * - `DrbdOptions/Net/always-asbp` - boolean
     * - `DrbdOptions/Net/rr-conflict` - enum
     *     * disconnect
     *     * call-pri-lost
     *     * violently
     *     * retry-connect
     *
     * - `DrbdOptions/Net/ping-timeout` - range[`1-300`]
     * - `DrbdOptions/Net/data-integrity-alg` - string
     * - `DrbdOptions/Net/tcp-cork` - boolean
     * - `DrbdOptions/Net/on-congestion` - enum
     *     * block
     *     * pull-ahead
     *     * disconnect
     *
     * - `DrbdOptions/Net/congestion-fill` - range[`0-20971520`]
     * - `DrbdOptions/Net/congestion-extents` - range[`67-65534`]
     * - `DrbdOptions/Net/csums-alg` - string
     * - `DrbdOptions/Net/csums-after-crash-only` - boolean
     * - `DrbdOptions/Net/verify-alg` - string
     * - `DrbdOptions/Net/use-rle` - boolean
     * - `DrbdOptions/Net/socket-check-timeout` - range[`0-300`]
     * - `DrbdOptions/Net/fencing` - enum
     *     * dont-care
     *     * resource-only
     *     * resource-and-stonith
     *
     * - `DrbdOptions/Net/max-buffers` - range[`32-131072`]
     * - `DrbdOptions/Net/allow-remote-read` - boolean
     * - `DrbdOptions/Handlers/after-resync-target` - string
     * - `DrbdOptions/Handlers/before-resync-target` - string
     * - `DrbdOptions/Handlers/before-resync-source` - string
     * - `DrbdOptions/Handlers/out-of-sync` - string
     * - `DrbdOptions/Handlers/quorum-lost` - string
     * - `DrbdOptions/Handlers/fence-peer` - string
     * - `DrbdOptions/Handlers/unfence-peer` - string
     * - `DrbdOptions/Handlers/initial-split-brain` - string
     * - `DrbdOptions/Handlers/local-io-error` - string
     * - `DrbdOptions/Handlers/pri-lost` - string
     * - `DrbdOptions/Handlers/pri-lost-after-sb` - string
     * - `DrbdOptions/Handlers/pri-on-incon-degr` - string
     * - `DrbdOptions/Handlers/split-brain` - string
     */
    put: operations['resourceDefinitionModify'];
    /** Delete a resource-definition */
    delete: operations['resourceDefinitionDelete'];
  };
  '/v1/resource-definitions/{resource}/clone': {
    /**
     * Clones the resource definition with all resources and volume with the current data and
     * the best/fastest possible clone method. Clone method depends on storage pool type:
     *   * LVM -> dd
     *   * LVM-thin -> snapshot -> logical volume
     *   * ZFS -> zfs send/recieve
     */
    post: operations['resourceDefinitionClone'];
  };
  '/v1/resource-definitions/{resource}/clone/{resourceClone}': {
    /** Get info of the current clone status. e.g. if completed. */
    get: operations['resourceDefinitionCloneStatus'];
  };
  '/v1/resource-definitions/{resource}/sync-status': {
    /** Get info if the resource is synced on all nodes */
    get: operations['resourceDefinitionSyncStatus'];
  };
  '/v1/resource-definitions/{resource}/files/{extFileName}': {
    /**
     * Enables deployment of a previously created external file for a resource definition.
     * This has the effect that the external file will be created in a host's file
     * system whenever `resource` is deployed on that host.
     */
    post: operations['resourceDeploy'];
    /**
     * Removes the requirement from this resource definition to create the given external file.
     * If nothing requires the external file to exist on a satellite, the satellite also will delete the
     * external file from the host's file system.
     */
    delete: operations['resourceUndeploy'];
  };
  '/v1/resource-definitions/properties/info': {
    /**
     * List all properties, including their names and descriptions, that can
     * be set for any given resource definition.
     */
    get: {
      responses: {
        /**
         * A map where the key is the property name and the value is a
         * PropsInfo object describing the property.
         */
        200: {
          content: {
            'application/json': {
              [key: string]: components['schemas']['PropsInfo'];
            };
          };
        };
      };
    };
  };
  '/v1/resource-definitions/{resource}/volume-definitions': {
    /**
     * Lists all volume definitions.
     *
     * A single volume definition can be queried by adding its name
     * to the resource string like:
     *
     * /v1/resource-definitions/rsc1/volume-definitions/0
     */
    get: operations['volumeDefinitionList'];
    /**
     * Adds a volume-definition.
     *
     * Required properties is only `size`, all other will be auto generated if not given.
     */
    post: operations['volumeDefinitionCreate'];
  };
  '/v1/resource-definitions/{resource}/volume-definitions/{volume_number}': {
    /**
     * Sets or modifies properties
     *
     * Possible properties are:
     * - `StorPoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Linstor storage pool name to use.
     *
     * - `StorPoolNameDrbdMeta` - regex[`^|.internal|[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Linstor storage pool name to use for external metadata.
     *
     * - `OverrideVlmId` - regex[`.*`]
     *
     *     Overwrites the generated '<resource-name>_<5 digit volume number>' volume name for migration purposes
     *
     * - `FileSystem/Type` - enum
     *
     *     File system type to use
     *
     *     * ext4
     *     * xfs
     *
     * - `FileSystem/MkfsParams` - string
     *
     *     Additional parameters for the mkfs command
     *
     * - `StorDriver/LvcreateType` - enum
     *     * linear
     *     * striped
     *     * mirror
     *     * raid0
     *     * raid1
     *     * raid4
     *     * raid5
     *     * raid6
     *     * raid10
     *     * lzma
     *     * lz4
     *
     * - `StorDriver/LvcreateOptions` - regex[`.*`]
     *
     *     Additional parameters added to every 'lvcreate ... ' command
     *
     * - `StorDriver/ZfscreateOptions` - regex[`.*`]
     *
     *     Additional parameters added to every 'zfs create ... ' command
     *
     * - `DrbdCurrentGi` - regex[`[a-fA-F0-9]{16}`]
     *
     *     Initial DRBD generation id, if initial sync is skipped, this ID will be set
     *
     * - `sys/fs/blkio_throttle_read` - long
     *
     *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device
     *
     * - `sys/fs/blkio_throttle_write` - long
     *
     *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device
     *
     * - `sys/fs/blkio_throttle_read_iops` - long
     *
     *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_iops_device
     *
     * - `sys/fs/blkio_throttle_write_iops` - long
     *
     *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_iops_device
     *
     * - `Writecache/PoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Linstor storage pool name for writecache
     *
     * - `Writecache/Size` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
     *
     *     Size of the writecache in % (0-100) or KiB otherwise
     *
     * - `Writecache/Options/StartSector` - long
     *
     *     offset from the start of cache device in 512-byte sectors
     *
     * - `Writecache/Options/HighWatermark` - long
     *
     *     start writeback when the number of used blocks reach this watermark
     *
     * - `Writecache/Options/LowWatermark` - long
     *
     *     stop writeback when the number of used blocks drops below this watermark
     *
     * - `Writecache/Options/WritebackJobs` - long
     *
     *     limit the number of blocks that are in flight during writeback. Setting this value reduces writeback throughput, but it may improve latency of read requests
     *
     * - `Writecache/Options/AutocommitBlocks` - long
     *
     *     when the application writes this amount of blocks without issuing the FLUSH request, the blocks are automatically commited
     *
     * - `Writecache/Options/AutocommitTime` - long
     *
     *     autocommit time in milliseconds. The data is automatically commited if this time passes and no FLUSH request is received
     *
     * - `Writecache/Options/Fua` - enum
     *
     *     "On" results in "fua" as argument, whereas the value "Off" results in "nofua" argument
     *
     *     * On
     *     * Off
     *
     * - `Writecache/Options/Additional` - string
     *
     *     Additional arguments passed through
     *
     * - `Cache/OpMode` - enum
     *
     *     Operation mode
     *
     *     * writeback
     *     * writethrough
     *     * passthrough
     *
     * - `Cache/MetaPool` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Name of the storage pool used for the cache metadata. If not specified, this will default to the CachePool property
     *
     * - `Cache/Metasize` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
     *
     *     Size of the cache in % (0-100) or KiB otherwise.
     *
     * - `Cache/CachePool` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Name of the storage pool used for the cache cache device
     *
     * - `Cache/Cachesize` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
     *
     *     Size of the cache in % (0-100) or KiB otherwise.
     *
     * - `Cache/Blocksize` - long
     *
     *     Block size
     *
     * - `Cache/Policy` - enum
     *
     *     Replacemant policy
     *
     *     * mq
     *     * smq
     *     * cleaner
     *
     * - `DrbdOptions/Disk/on-io-error` - enum
     *     * pass_on
     *     * call-local-io-error
     *     * detach
     *
     * - `DrbdOptions/Disk/disk-barrier` - boolean
     * - `DrbdOptions/Disk/disk-flushes` - boolean
     * - `DrbdOptions/Disk/disk-drain` - boolean
     * - `DrbdOptions/Disk/md-flushes` - boolean
     * - `DrbdOptions/Disk/resync-after` - string
     * - `DrbdOptions/Disk/al-extents` - range[`67-65534`]
     * - `DrbdOptions/Disk/al-updates` - boolean
     * - `DrbdOptions/Disk/discard-zeroes-if-aligned` - boolean
     * - `DrbdOptions/Disk/disable-write-same` - boolean
     * - `DrbdOptions/Disk/disk-timeout` - range[`0-6000`]
     * - `DrbdOptions/Disk/read-balancing` - enum
     *     * prefer-local
     *     * prefer-remote
     *     * round-robin
     *     * least-pending
     *     * when-congested-remote
     *     * 32K-striping
     *     * 64K-striping
     *     * 128K-striping
     *     * 256K-striping
     *     * 512K-striping
     *     * 1M-striping
     *
     * - `DrbdOptions/Disk/rs-discard-granularity` - range[`0-1048576`]
     */
    put: operations['volumeDefinitionModify'];
    /** Delete a volume-definition */
    delete: operations['volumeDefinitionDelete'];
  };
  '/v1/resource-definitions/{resource}/volume-definitions/properties/info': {
    /**
     * List all properties, including their names and descriptions, that can
     * be set for any given volume definition of a particular resource.
     */
    get: {
      parameters: {
        path: {
          /** resource to use */
          resource: string;
        };
      };
      responses: {
        /**
         * A map where the key is the property name and the value is a
         * PropsInfo object describing the property.
         */
        200: {
          content: {
            'application/json': {
              [key: string]: components['schemas']['PropsInfo'];
            };
          };
        };
      };
    };
  };
  '/v1/resource-definitions/{resource}/resources': {
    /**
     * Lists all resources for a resource-definition.
     *
     * A single resource can be queried by adding its name
     * to the resource string like:
     *
     * /v1/resource-definitions/rsc1/resources/nodeA
     */
    get: operations['resourceList'];
    /** Adds one or more resource(s). */
    post: operations['resourceCreate'];
  };
  '/v1/resource-definitions/{resource}/resources/{node}': {
    /**
     * Sets or modifies properties
     *
     * Possible properties are:
     * - `StorPoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Linstor storage pool name to use.
     *
     * - `StorPoolNameDrbdMeta` - regex[`^|.internal|[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Linstor storage pool name to use for external metadata.
     *
     * - `PrefNic` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Preferred network interface to use
     *
     * - `PeerSlots` - range[`1-31`]
     *
     *     DRBD peer slots present on resource
     *
     * - `FileSystem/Type` - enum
     *
     *     File system type to use
     *
     *     * ext4
     *     * xfs
     *
     * - `FileSystem/MkfsParams` - string
     *
     *     Additional parameters for the mkfs command
     *
     * - `NVMe/PrefNic` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Preferred network interface to use
     *
     * - `sys/fs/blkio_throttle_read` - long
     *
     *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device
     *
     * - `sys/fs/blkio_throttle_write` - long
     *
     *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device
     *
     * - `sys/fs/blkio_throttle_read_iops` - long
     *
     *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_iops_device
     *
     * - `sys/fs/blkio_throttle_write_iops` - long
     *
     *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_iops_device
     *
     * - `DrbdOptions/auto-diskful-allow-cleanup` - boolean_true_false
     *
     *     Allows this resource to be cleaned up after toggle-disk + resync is finished
     */
    put: operations['resourceModify'];
    /**
     * Adds a resource on a node.
     *
     * To use a specific storage pool add the `StorPoolName` property
     * and use the storage pool name as value.
     * If the `StorPoolName` property is not set, the `DfltStorPool` will be used.
     *
     * To create a diskless resource you have to set the "DISKLESS" flag in the flags list.
     * ```
     * {
     *   "resource": {
     *     "flags": ["DISKLESS"]
     *   }
     * }
     * ```
     */
    post: operations['resourceCreateOnNode'];
    /** Delete a resource on a node */
    delete: operations['resourceDelete'];
  };
  '/v1/resource-definitions/{resource}/resources/{node}/make-available': {
    /**
     * Adds a resource on a node if not already deployed.
     *
     * New resources will be diskless, if possible. To force creation of
     * a diskful resource, set `diskful` to `true` in the request body.
     *
     * Optionally, you can override the layer stack for the created resource.
     * If not given, the default configuration for the resource definition is
     * used.
     *
     * The storage pool will be selected by the autoplacer.
     */
    post: operations['resourceMakeAvailableOnNode'];
  };
  '/v1/resource-definitions/{resource}/resources/{node}/activate': {
    /** Activates the given resource if possible */
    post: operations['ActivateRsc'];
  };
  '/v1/resource-definitions/{resource}/resources/{node}/deactivate': {
    /** Deactivates the given resource if possible */
    post: operations['DeactivateRsc'];
  };
  '/v1/resource-definitions/{resource}/resources/properties/info': {
    /**
     * List all properties, including their names and descriptions, that can
     * be set for any given resource in a particular resource definition.
     */
    get: {
      parameters: {
        path: {
          /** resource to use */
          resource: string;
        };
      };
      responses: {
        /**
         * A map where the key is the property name and the value is a
         * PropsInfo object describing the property.
         */
        200: {
          content: {
            'application/json': {
              [key: string]: components['schemas']['PropsInfo'];
            };
          };
        };
      };
    };
  };
  '/v1/resource-definitions/{resource}/resources/{node}/volumes': {
    /**
     * Lists all volumes for a resource-definition.
     *
     * A single volume can be queried by adding its volume number
     * to the resource string like:
     *
     * /v1/resource-definitions/rsc1/resources/nodeA/volumes/0
     */
    get: operations['resourceVolumeList'];
  };
  '/v1/resource-definitions/{resource}/resources/{node}/volumes/{volume_number}': {
    /**
     * Sets or modifies properties
     *
     * Possible properties are:
     * - `sys/fs/blkio_throttle_read` - number
     * - `sys/fs/blkio_throttle_write` - number
     */
    put: operations['volumeModify'];
  };
  '/v1/resource-definitions/{resource}/resources/{node}/volumes/properties/info': {
    /**
     * List all properties, including their names and descriptions, that can
     * be set for any given volume of a particular resource on a particular node.
     */
    get: {
      parameters: {
        path: {
          /** node to use */
          node: string;
          /** resource to use */
          resource: string;
        };
      };
      responses: {
        /**
         * A map where the key is the property name and the value is a
         * PropsInfo object describing the property.
         */
        200: {
          content: {
            'application/json': {
              [key: string]: components['schemas']['PropsInfo'];
            };
          };
        };
      };
    };
  };
  '/v1/resource-definitions/{resource}/resources/{node}/toggle-disk/diskless': {
    /** toggle a resource to a diskless resource */
    put: operations['resourceToggleDiskless'];
  };
  '/v1/resource-definitions/{resource}/resources/{node}/toggle-disk/diskless/{disklesspool}': {
    /** toggle a resource to a diskless. */
    put: operations['resourceToggleDisklessDisklesspool'];
  };
  '/v1/resource-definitions/{resource}/resources/{node}/toggle-disk/diskful': {
    /** toggle a resource to a diskful resource using the default storage pool */
    put: operations['resourceToggleDiskful'];
  };
  '/v1/resource-definitions/{resource}/resources/{node}/toggle-disk/diskful/{storagepool}': {
    /** toggle a resource to a diskful resource */
    put: operations['resourceToggleDiskfulStoragepool'];
  };
  '/v1/resource-definitions/{resource}/resources/{node}/migrate-disk/{fromnode}': {
    /** migrate a resource to another node without reducing the redundancy count */
    put: operations['resourceMigrateDisk'];
  };
  '/v1/resource-definitions/{resource}/resources/{node}/migrate-disk/{fromnode}/{storagepool}': {
    /** migrate a resource to another node without reducing the redundency count */
    put: operations['resourceMigrateDiskStoragepool'];
  };
  '/v1/resource-definitions/{resource}/autoplace': {
    /**
     * Auto place the resource on the specified place_count redundency.
     * If place_count isn't given 2 is the default.
     */
    post: operations['resourceAutoplace'];
  };
  '/v1/resource-definitions/{resource}/resource-connections': {
    /** List all resource connections for resource */
    get: operations['resourceConnectionsList'];
  };
  '/v1/resource-definitions/{resource}/resource-connections/{node_a}/{node_b}': {
    /** show the specified resource connection */
    get: operations['resourceConnectionList'];
    /**
     * Sets or modifies properties
     *
     * Possible properties are:
     * - `DrbdOptions/PeerDevice/resync-rate` - range[`1-8388608`]
     * - `DrbdOptions/PeerDevice/c-plan-ahead` - range[`0-300`]
     * - `DrbdOptions/PeerDevice/c-delay-target` - range[`1-100`]
     * - `DrbdOptions/PeerDevice/c-fill-target` - range[`0-1048576`]
     * - `DrbdOptions/PeerDevice/c-max-rate` - range[`250-4194304`]
     * - `DrbdOptions/PeerDevice/c-min-rate` - range[`0-4194304`]
     * - `DrbdOptions/PeerDevice/bitmap` - boolean
     * - `DrbdOptions/Net/transport` - string
     * - `DrbdOptions/Net/protocol` - enum
     *     * A
     *     * B
     *     * C
     *
     * - `DrbdOptions/Net/timeout` - range[`1-600`]
     * - `DrbdOptions/Net/max-epoch-size` - range[`1-20000`]
     * - `DrbdOptions/Net/connect-int` - range[`1-120`]
     * - `DrbdOptions/Net/ping-int` - range[`1-120`]
     * - `DrbdOptions/Net/sndbuf-size` - range[`0-10485760`]
     * - `DrbdOptions/Net/rcvbuf-size` - range[`0-10485760`]
     * - `DrbdOptions/Net/ko-count` - range[`0-200`]
     * - `DrbdOptions/Net/allow-two-primaries` - boolean
     * - `DrbdOptions/Net/cram-hmac-alg` - string
     * - `DrbdOptions/Net/shared-secret` - string
     * - `DrbdOptions/Net/after-sb-0pri` - enum
     *     * disconnect
     *     * discard-younger-primary
     *     * discard-older-primary
     *     * discard-zero-changes
     *     * discard-least-changes
     *     * discard-local
     *     * discard-remote
     *
     * - `DrbdOptions/Net/after-sb-1pri` - enum
     *     * disconnect
     *     * consensus
     *     * discard-secondary
     *     * call-pri-lost-after-sb
     *     * violently-as0p
     *
     * - `DrbdOptions/Net/after-sb-2pri` - enum
     *     * disconnect
     *     * call-pri-lost-after-sb
     *     * violently-as0p
     *
     * - `DrbdOptions/Net/always-asbp` - boolean
     * - `DrbdOptions/Net/rr-conflict` - enum
     *     * disconnect
     *     * call-pri-lost
     *     * violently
     *     * retry-connect
     *
     * - `DrbdOptions/Net/ping-timeout` - range[`1-300`]
     * - `DrbdOptions/Net/data-integrity-alg` - string
     * - `DrbdOptions/Net/tcp-cork` - boolean
     * - `DrbdOptions/Net/on-congestion` - enum
     *     * block
     *     * pull-ahead
     *     * disconnect
     *
     * - `DrbdOptions/Net/congestion-fill` - range[`0-20971520`]
     * - `DrbdOptions/Net/congestion-extents` - range[`67-65534`]
     * - `DrbdOptions/Net/csums-alg` - string
     * - `DrbdOptions/Net/csums-after-crash-only` - boolean
     * - `DrbdOptions/Net/verify-alg` - string
     * - `DrbdOptions/Net/use-rle` - boolean
     * - `DrbdOptions/Net/socket-check-timeout` - range[`0-300`]
     * - `DrbdOptions/Net/fencing` - enum
     *     * dont-care
     *     * resource-only
     *     * resource-and-stonith
     *
     * - `DrbdOptions/Net/max-buffers` - range[`32-131072`]
     * - `DrbdOptions/Net/allow-remote-read` - boolean
     */
    put: operations['resourceConnectionModify'];
  };
  '/v1/resource-definitions/{resource}/resource-connections/properties/info': {
    /**
     * List all properties, including their names and descriptions, that can
     * be set for any given connection of a particular resource.
     */
    get: {
      parameters: {
        path: {
          /** resource to use */
          resource: string;
        };
      };
      responses: {
        /**
         * A map where the key is the property name and the value is a
         * PropsInfo object describing the property.
         */
        200: {
          content: {
            'application/json': {
              [key: string]: components['schemas']['PropsInfo'];
            };
          };
        };
      };
    };
  };
  '/v1/resource-definitions/{resource}/snapshots': {
    /** List snapshots for a resource */
    get: operations['resourceSnapshotsList'];
    /** Create a snapshot for a resource */
    post: operations['resourceSnapshotCreate'];
  };
  '/v1/resource-definitions/{resource}/snapshots/{snapshot}': {
    /** List the given snapshot for a resource */
    get: operations['resourceSnapshotList'];
    /** Delete a snapshot */
    delete: operations['resourceSnapshotDelete'];
  };
  '/v1/resource-definitions/{resource}/snapshot-restore-resource/{snapshot}': {
    /** Restore a snapshot to a new resource */
    post: operations['resourceSnapshotRestore'];
  };
  '/v1/resource-definitions/{resource}/snapshot-restore-volume-definition/{snapshot}': {
    /** Restore a snapshot volume definition to a new resource */
    post: operations['resourceSnapshotsRestoreVolumeDefinition'];
  };
  '/v1/resource-definitions/{resource}/snapshot-rollback/{snapshot}': {
    /** Rollback a resource to the snapshot state */
    post: operations['resourceSnapshotRollback'];
  };
  '/v1/resource-definitions/{resource}/snapshot-shipping': {
    /** Transfers the resource from one node to another based on snapshot-shipping */
    post: operations['snapshotShipping'];
  };
  '/v1/resource-groups': {
    /**
     * Lists all resource groups.
     *
     * A single resource group can be queried by adding its name
     * to the resource string like:
     *
     * /v1/resource-groups/rscgrp1
     */
    get: operations['resourceGroupList'];
    /**
     * Adds a resource-group.
     *
     * Only required property is the name of the resource group.
     * All other properties are optional.
     */
    post: operations['resourceGroupCreate'];
  };
  '/v1/stats/resource-groups': {
    /** Returns a resource group stats object. */
    get: operations['resourceGroupStats'];
  };
  '/v1/resource-groups/{resource_group}': {
    /**
     * Sets or modifies properties
     *
     * Possible properties are:
     * - `StorPoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Linstor storage pool name to use.
     *
     * - `PeerSlotsNewResource` - range[`1-31`]
     *
     *     DRBD peer slots to allocate for newly created resources (default 7), the number of peer slots cannot be changed once the resource is created, so allow sufficient slots to increase redundancy in the future
     *
     * - `DrbdProxy/CompressionType` - enum
     *     * zlib
     *     * lzma
     *     * lz4
     *
     * - `FileSystem/Type` - enum
     *
     *     File system type to use
     *
     *     * ext4
     *     * xfs
     *
     * - `FileSystem/MkfsParams` - string
     *
     *     Additional parameters for the mkfs command
     *
     * - `NVMe/enabled` - enum
     *     * rdma
     *     * tcp
     *
     * - `NVMe/enabled` - range[`1-65535`]
     * - `DrbdOptions/Disk/read-balancing` - enum
     *     * prefer-local
     *     * prefer-remote
     *     * round-robin
     *     * least-pending
     *     * when-congested-remote
     *     * 32K-striping
     *     * 64K-striping
     *     * 128K-striping
     *     * 256K-striping
     *     * 512K-striping
     *     * 1M-striping
     *
     * - `DrbdOptions/Disk/on-io-error` - enum
     *     * pass_on
     *     * call-local-io-error
     *     * detach
     *
     * - `DrbdOptions/Disk/disk-drain` - boolean
     * - `DrbdOptions/Disk/resync-after` - string
     * - `DrbdOptions/Disk/disk-timeout` - range[`0-6000`]
     * - `DrbdOptions/Disk/disable-write-same` - boolean
     * - `DrbdOptions/Disk/rs-discard-granularity` - range[`0-1048576`]
     * - `DrbdOptions/Disk/disk-flushes` - boolean
     * - `DrbdOptions/Disk/al-extents` - range[`67-65534`]
     * - `DrbdOptions/Disk/al-updates` - boolean
     * - `DrbdOptions/Disk/md-flushes` - boolean
     * - `DrbdOptions/Disk/disk-barrier` - boolean
     * - `DrbdOptions/Disk/discard-zeroes-if-aligned` - boolean
     * - `DrbdOptions/PeerDevice/c-fill-target` - range[`0-1048576`]
     * - `DrbdOptions/PeerDevice/c-max-rate` - range[`250-4194304`]
     * - `DrbdOptions/PeerDevice/resync-rate` - range[`1-8388608`]
     * - `DrbdOptions/PeerDevice/c-delay-target` - range[`1-100`]
     * - `DrbdOptions/PeerDevice/c-min-rate` - range[`0-4194304`]
     * - `DrbdOptions/PeerDevice/bitmap` - boolean
     * - `DrbdOptions/PeerDevice/c-plan-ahead` - range[`0-300`]
     * - `DrbdOptions/Resource/peer-ack-delay` - range[`1-10000`]
     * - `DrbdOptions/Resource/quorum-minimum-redundancy` - enum [`1-32`]
     *     * off
     *     * majority
     *     * all
     *
     * - `DrbdOptions/Resource/max-io-depth` - range[`4-4294967295`]
     * - `DrbdOptions/Resource/auto-promote-timeout` - range[`0-600`]
     * - `DrbdOptions/Resource/quorum` - enum [`1-32`]
     *     * off
     *     * majority
     *     * all
     *
     * - `DrbdOptions/Resource/on-no-data-accessible` - enum
     *     * io-error
     *     * suspend-io
     *
     * - `DrbdOptions/Resource/auto-promote` - boolean
     * - `DrbdOptions/Resource/cpu-mask` - string
     * - `DrbdOptions/Resource/twopc-timeout` - range[`50-600`]
     * - `DrbdOptions/Resource/twopc-retry-timeout` - range[`1-50`]
     * - `DrbdOptions/Resource/peer-ack-window` - range[`2048-204800`]
     * - `DrbdOptions/Resource/on-no-quorum` - enum
     *     * io-error
     *     * suspend-io
     *
     * - `DrbdOptions/Net/max-epoch-size` - range[`1-20000`]
     * - `DrbdOptions/Net/protocol` - enum
     *     * A
     *     * B
     *     * C
     *
     * - `DrbdOptions/Net/allow-two-primaries` - boolean
     * - `DrbdOptions/Net/after-sb-0pri` - enum
     *     * disconnect
     *     * discard-younger-primary
     *     * discard-older-primary
     *     * discard-zero-changes
     *     * discard-least-changes
     *     * discard-local
     *     * discard-remote
     *
     * - `DrbdOptions/Net/ko-count` - range[`0-200`]
     * - `DrbdOptions/Net/data-integrity-alg` - string
     * - `DrbdOptions/Net/ping-timeout` - range[`1-300`]
     * - `DrbdOptions/Net/sndbuf-size` - range[`0-10485760`]
     * - `DrbdOptions/Net/transport` - string
     * - `DrbdOptions/Net/rcvbuf-size` - range[`0-10485760`]
     * - `DrbdOptions/Net/max-buffers` - range[`32-131072`]
     * - `DrbdOptions/Net/fencing` - enum
     *     * dont-care
     *     * resource-only
     *     * resource-and-stonith
     *
     * - `DrbdOptions/Net/csums-alg` - string
     * - `DrbdOptions/Net/always-asbp` - boolean
     * - `DrbdOptions/Net/congestion-extents` - range[`67-65534`]
     * - `DrbdOptions/Net/on-congestion` - enum
     *     * block
     *     * pull-ahead
     *     * disconnect
     *
     * - `DrbdOptions/Net/ping-int` - range[`1-120`]
     * - `DrbdOptions/Net/rr-conflict` - enum
     *     * disconnect
     *     * call-pri-lost
     *     * violently
     *
     * - `DrbdOptions/Net/tcp-cork` - boolean
     * - `DrbdOptions/Net/use-rle` - boolean
     * - `DrbdOptions/Net/csums-after-crash-only` - boolean
     * - `DrbdOptions/Net/socket-check-timeout` - range[`0-300`]
     * - `DrbdOptions/Net/congestion-fill` - range[`0-20971520`]
     * - `DrbdOptions/Net/cram-hmac-alg` - string
     * - `DrbdOptions/Net/verify-alg` - string
     * - `DrbdOptions/Net/shared-secret` - string
     * - `DrbdOptions/Net/connect-int` - range[`1-120`]
     * - `DrbdOptions/Net/timeout` - range[`1-600`]
     * - `DrbdOptions/Net/after-sb-2pri` - enum
     *     * disconnect
     *     * call-pri-lost-after-sb
     *     * violently-as0p
     *
     * - `DrbdOptions/Net/after-sb-1pri` - enum
     *     * disconnect
     *     * consensus
     *     * discard-secondary
     *     * call-pri-lost-after-sb
     *     * violently-as0p
     *
     * - `DrbdOptions/Handlers/after-resync-target` - string
     * - `DrbdOptions/Handlers/before-resync-target` - string
     * - `DrbdOptions/Handlers/before-resync-source` - string
     * - `DrbdOptions/Handlers/out-of-sync` - string
     * - `DrbdOptions/Handlers/quorum-lost` - string
     * - `DrbdOptions/Handlers/fence-peer` - string
     * - `DrbdOptions/Handlers/unfence-peer` - string
     * - `DrbdOptions/Handlers/initial-split-brain` - string
     * - `DrbdOptions/Handlers/local-io-error` - string
     * - `DrbdOptions/Handlers/pri-lost` - string
     * - `DrbdOptions/Handlers/pri-lost-after-sb` - string
     * - `DrbdOptions/Handlers/pri-on-incon-degr` - string
     * - `DrbdOptions/Handlers/split-brain` - string
     */
    put: operations['resourceGroupModify'];
    /** Delete a resource-group */
    delete: operations['resourceGroupDelete'];
  };
  '/v1/resource-groups/properties/info': {
    /**
     * List all properties, including their names and descriptions, that can
     * be set for any given resource group.
     */
    get: {
      responses: {
        /**
         * A map where the key is the property name and the value is a
         * PropsInfo object describing the property.
         */
        200: {
          content: {
            'application/json': {
              [key: string]: components['schemas']['PropsInfo'];
            };
          };
        };
      };
    };
  };
  '/v1/resource-groups/{resource_group}/spawn': {
    /** Creates a new resource-definition and auto-deploys if configured to do so. */
    post: operations['resourceGroupSpawn'];
  };
  '/v1/resource-groups/{resource_group}/volume-groups': {
    /**
     * Lists all volume groups.
     *
     * A single volume group can be queried by adding its name
     * to the resource string like:
     *
     * /v1/resource-groups/rscgrp1/volume-groups/0
     */
    get: operations['volumeGroupList'];
    /** Adds a volume-group. */
    post: operations['volumeGroupCreate'];
  };
  '/v1/resource-groups/{resource_group}/volume-groups/{volume_number}': {
    /**
     * Sets or modifies properties
     *
     * Possible properties are:
     * - `StorPoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Linstor storage pool name to use.
     *
     * - `OverrideVlmId` - regex[`.*`]
     *
     *     Overwrites the generated '<resource-name>_<5 digit volume number>' volume name for migration purposes
     *
     * - `AllowLargerVolumeSize` - boolean_true_false
     *
     *     Do not fail when the underlying volume is larger than expected
     *
     * - `FileSystem/Type` - enum
     *
     *     File system type to use
     *
     *     * ext4
     *     * xfs
     *
     * - `FileSystem/MkfsParams` - string
     *
     *     Additional parameters for the mkfs command
     *
     * - `StorDriver/LvcreateType` - enum
     *     * linear
     *     * striped
     *     * mirror
     *     * raid0
     *     * raid1
     *     * raid4
     *     * raid5
     *     * raid6
     *     * raid10
     *     * lzma
     *     * lz4
     *
     * - `DrbdCurrentGi` - regex[`[a-fA-F0-9]{16}`]
     * - `DrbdOptions/Disk/read-balancing` - enum
     *     * prefer-local
     *     * prefer-remote
     *     * round-robin
     *     * least-pending
     *     * when-congested-remote
     *     * 32K-striping
     *     * 64K-striping
     *     * 128K-striping
     *     * 256K-striping
     *     * 512K-striping
     *     * 1M-striping
     *
     * - `DrbdOptions/Disk/on-io-error` - enum
     *     * pass_on
     *     * call-local-io-error
     *     * detach
     *
     * - `DrbdOptions/Disk/disk-drain` - boolean
     * - `DrbdOptions/Disk/resync-after` - string
     * - `DrbdOptions/Disk/disk-timeout` - range[`0-6000`]
     * - `DrbdOptions/Disk/disable-write-same` - boolean
     * - `DrbdOptions/Disk/rs-discard-granularity` - range[`0-1048576`]
     * - `DrbdOptions/Disk/disk-flushes` - boolean
     * - `DrbdOptions/Disk/al-extents` - range[`67-65534`]
     * - `DrbdOptions/Disk/al-updates` - boolean
     * - `DrbdOptions/Disk/md-flushes` - boolean
     * - `DrbdOptions/Disk/disk-barrier` - boolean
     * - `DrbdOptions/Disk/discard-zeroes-if-aligned` - boolean
     */
    put: operations['volumeGroupModify'];
    /** Delete a volume-group */
    delete: operations['volumeGroupDelete'];
  };
  '/v1/resource-groups/{resource_group}/volume-groups/properties/info': {
    /**
     * List all properties, including their names and descriptions, that can
     * be set for any given volume group of a particular resource group.
     */
    get: {
      parameters: {
        path: {
          /** resource group to use */
          resource_group: string;
        };
      };
      responses: {
        /**
         * A map where the key is the property name and the value is a
         * PropsInfo object describing the property.
         */
        200: {
          content: {
            'application/json': {
              [key: string]: components['schemas']['PropsInfo'];
            };
          };
        };
      };
    };
  };
  '/v1/resource-groups/{resource_group}/query-max-volume-size': {
    /** Query the maximum possible volume size storage pools */
    get: operations['queryMaxVolumeSizeFromRscGrp'];
  };
  '/v1/resource-groups/{resource_group}/adjust': {
    /** Adjusts (calls autoplace for) all resource-definitions of the given resource-group */
    post: operations['resourceGroupAdjust'];
  };
  '/v1/resource-groups/adjustall': {
    /** Adjusts (calls autoplace for) all resource-definitions of all resource-groups */
    post: operations['resourceGroupAdjustAll'];
  };
  '/v1/controller/properties': {
    /** Lists all controller properties. */
    get: operations['controllerPropertyList'];
    /**
     * Sets or modifies properties
     *
     * Possible properties are:
     * - `TcpPortAutoRange` - regex[`[0-9]+-[0-9]+`]
     *
     *     Range for auto-allocation of resource TCP ports
     *
     * - `MinorNrAutoRange` - regex[`[0-9]+-[0-9]+`]
     *
     *     Range for auto-allocation of volume minor numbers
     *
     * - `PeerSlotsNewResource` - range[`1-31`]
     *
     *     DRBD peer slots to allocate for newly created resources (default 7), the number of peer slots cannot be changed once the resource is created, so allow sufficient slots to increase redundancy in the future
     *
     * - `StorDriver/DMStats` - boolean_true_false
     *
     *     Enable dmstats on lvm create
     *
     * - `REST/disable-http-metrics` - boolean_true_false
     *
     *     Disable Prometheus /metrics on HTTP, if HTTPS is enabled
     *
     * - `DrbdOptions/AutoEvictAfterTime` - long
     *
     *     Time a node can be offline before it is declared EVICTED in minutes
     *
     * - `DrbdOptions/AutoEvictMaxDisconnectedNodes` - range[`0-100`]
     *
     *     Percentage(0-100) of nodes that can disconnect at the same time without the controller stopping the max_offline_time timer
     *
     * - `DrbdOptions/AutoEvictMinReplicaCount` - long
     *
     *     The minimum amount of replicas that should be present for a resource at all times.
     *
     * - `DrbdOptions/AutoEvictAllowEviction` - boolean_true_false
     *
     *     If set to true on a node, it cannot be evicted anymore
     *
     * - `NVMe/TRType` - enum
     *
     *     NVMe transportion type
     *
     *     * rdma
     *     * tcp
     *
     * - `NVMe/Port` - range[`1-65535`]
     *
     *     NVMe port
     *
     * - `NVMe/PrefNic` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Preferred network interface to use
     *
     * - `StorDriver/WaitTimeoutAfterCreate` - regex[`[0-9]+`]
     * - `sys/fs/blkio_throttle_read` - long
     *
     *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device
     *
     * - `sys/fs/blkio_throttle_write` - long
     *
     *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device
     *
     * - `sys/fs/blkio_throttle_read_iops` - long
     *
     *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_iops_device
     *
     * - `sys/fs/blkio_throttle_write_iops` - long
     *
     *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_iops_device
     *
     * - `SearchDomain` - string
     *
     *     Search domain node names, if no FQDN is given.
     *
     * - `ExtCmdWaitTimeout` - long
     *
     *     Wait timeout for an external command in milliseconds
     *
     * - `DrbdOptions/auto-quorum` - enum
     *
     *     Enables automatic setting of the 'quroum' and 'on-no-quroum' property
     *
     *     * io-error
     *     * suspend-io
     *     * disabled
     *
     * - `DrbdOptions/auto-add-quorum-tiebreaker` - boolean_true_false
     *
     *     Enables automatic management (creation and deletion) of tie breaking resource
     *
     * - `DrbdOptions/auto-diskful` - long
     *
     *     Makes a resource diskful if it was continously diskless primary for X minutes
     *
     * - `DrbdOptions/auto-diskful-allow-cleanup` - boolean_true_false
     *
     *     Allows this resource to be cleaned up after toggle-disk + resync is finished
     *
     * - `Writecache/PoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Linstor storage pool name for writecache
     *
     * - `Writecache/Size` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
     *
     *     Size of the writecache in % (0-100) or KiB otherwise
     *
     * - `Writecache/Options/StartSector` - long
     *
     *     offset from the start of cache device in 512-byte sectors
     *
     * - `Writecache/Options/HighWatermark` - long
     *
     *     start writeback when the number of used blocks reach this watermark
     *
     * - `Writecache/Options/LowWatermark` - long
     *
     *     stop writeback when the number of used blocks drops below this watermark
     *
     * - `Writecache/Options/WritebackJobs` - long
     *
     *     limit the number of blocks that are in flight during writeback. Setting this value reduces writeback throughput, but it may improve latency of read requests
     *
     * - `Writecache/Options/AutocommitBlocks` - long
     *
     *     when the application writes this amount of blocks without issuing the FLUSH request, the blocks are automatically commited
     *
     * - `Writecache/Options/AutocommitTime` - long
     *
     *     autocommit time in milliseconds. The data is automatically commited if this time passes and no FLUSH request is received
     *
     * - `Writecache/Options/Fua` - enum
     *
     *     "On" results in "fua" as argument, whereas the value "Off" results in "nofua" argument
     *
     *     * On
     *     * Off
     *
     * - `Writecache/Options/Additional` - string
     *
     *     Additional arguments passed through
     *
     * - `Cache/OpMode` - enum
     *
     *     Operation mode
     *
     *     * writeback
     *     * writethrough
     *     * passthrough
     *
     * - `Cache/MetaPool` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Name of the storage pool used for the cache metadata. If not specified, this will default to the CachePool property
     *
     * - `Cache/Metasize` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
     *
     *     Size of the cache in % (0-100) or KiB otherwise.
     *
     * - `Cache/CachePool` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
     *
     *     Name of the storage pool used for the cache cache device
     *
     * - `Cache/Cachesize` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
     *
     *     Size of the cache in % (0-100) or KiB otherwise.
     *
     * - `Cache/Blocksize` - long
     *
     *     Block size
     *
     * - `Cache/Policy` - enum
     *
     *     Replacemant policy
     *
     *     * mq
     *     * smq
     *     * cleaner
     *
     * - `StorDriver/LvcreateOptions` - regex[`.*`]
     *
     *     Additional parameters added to every 'lvcreate ... ' command
     *
     * - `StorDriver/ZfscreateOptions` - regex[`.*`]
     *
     *     Additional parameters added to every 'zfs create ... ' command
     *
     * - `StorDriver/Openflex/ApiHost` - regex[`.+`]
     *
     *     Openflex API host name
     *
     * - `StorDriver/Openflex/ApiPort` - regex[`[0-9]+`]
     *
     *     Openflex API port
     *
     * - `StorDriver/Openflex/UserName` - regex[`.+`]
     *
     *     Openflex user name
     *
     * - `StorDriver/Openflex/UserPassword` - regex[`.+`]
     *
     *     Openflex password
     *
     * - `StorDriver/Openflex/JobWaitDelay` - regex[`[0-9]+`]
     *
     *     Delay in milliseconds linstor waits between fetching the job status
     *
     * - `StorDriver/Openflex/JobWaitMaxCount` - regex[`[0-9]+`]
     *
     *     Maximum retries with wait delay until openflex fails
     *
     * - `Autoplacer/Weights/MaxFreeSpace` - regex[`^[0-9]+([.][0-9]+)?`]
     *
     *     Weight of 'MaxFreeSpace' autoplacer-strategy
     *
     * - `Autoplacer/Weights/MinReservedSpace` - regex[`^[0-9]+([.][0-9]+)?`]
     *
     *     Weight of 'MinReservedSpace' autoplacer-strategy
     *
     * - `Autoplacer/Weights/MinRscCount` - regex[`^[0-9]+([.][0-9]+)?`]
     *
     *     Weight of 'MinRscCount' autoplacer-strategy
     *
     * - `Autoplacer/Weights/MaxThroughput` - regex[`^[0-9]+([.][0-9]+)?`]
     *
     *     Weight of 'MaxThroughput' autoplacer-strategy
     *
     * - `Autoplacer/PreSelectScript` - string
     *
     *     Filename of the preselection script. File must be in /etc/linstor/selector/
     *
     * - `Autoplacer/PreSelectScriptTimeout` - long
     *
     *     Timeout in ms Linstor waits for the script to run.
     *
     * - `Autoplacer/MaxThroughput` - long
     *
     *     The maximum throughput the given storage pool is capable of.
     *
     * - `DrbdProxy/AutoEnable` - boolean_true_false
     * - `Site` - string
     * - `UpdateCacheInterval` - long
     *
     *     Interval for space cache background updates in seconds
     *
     * - `SnapshotShipping/TcpPortRange` - regex[`[0-9]+-[0-9]+`]
     *
     *     Range for allocation of snapshot shipping TCP ports
     *
     * - `DrbdOptions/Disk/on-io-error` - enum
     *     * pass_on
     *     * call-local-io-error
     *     * detach
     *
     * - `DrbdOptions/Disk/disk-barrier` - boolean
     * - `DrbdOptions/Disk/disk-flushes` - boolean
     * - `DrbdOptions/Disk/disk-drain` - boolean
     * - `DrbdOptions/Disk/md-flushes` - boolean
     * - `DrbdOptions/Disk/resync-after` - string
     * - `DrbdOptions/Disk/al-extents` - range[`67-65534`]
     * - `DrbdOptions/Disk/al-updates` - boolean
     * - `DrbdOptions/Disk/discard-zeroes-if-aligned` - boolean
     * - `DrbdOptions/Disk/disable-write-same` - boolean
     * - `DrbdOptions/Disk/disk-timeout` - range[`0-6000`]
     * - `DrbdOptions/Disk/read-balancing` - enum
     *     * prefer-local
     *     * prefer-remote
     *     * round-robin
     *     * least-pending
     *     * when-congested-remote
     *     * 32K-striping
     *     * 64K-striping
     *     * 128K-striping
     *     * 256K-striping
     *     * 512K-striping
     *     * 1M-striping
     *
     * - `DrbdOptions/Disk/rs-discard-granularity` - range[`0-1048576`]
     * - `DrbdOptions/PeerDevice/resync-rate` - range[`1-8388608`]
     * - `DrbdOptions/PeerDevice/c-plan-ahead` - range[`0-300`]
     * - `DrbdOptions/PeerDevice/c-delay-target` - range[`1-100`]
     * - `DrbdOptions/PeerDevice/c-fill-target` - range[`0-1048576`]
     * - `DrbdOptions/PeerDevice/c-max-rate` - range[`250-4194304`]
     * - `DrbdOptions/PeerDevice/c-min-rate` - range[`0-4194304`]
     * - `DrbdOptions/PeerDevice/bitmap` - boolean
     * - `DrbdOptions/Resource/cpu-mask` - string
     * - `DrbdOptions/Resource/on-no-data-accessible` - enum
     *     * io-error
     *     * suspend-io
     *
     * - `DrbdOptions/Resource/auto-promote` - boolean
     * - `DrbdOptions/Resource/peer-ack-window` - range[`2048-204800`]
     * - `DrbdOptions/Resource/peer-ack-delay` - range[`1-10000`]
     * - `DrbdOptions/Resource/twopc-timeout` - range[`50-600`]
     * - `DrbdOptions/Resource/twopc-retry-timeout` - range[`1-50`]
     * - `DrbdOptions/Resource/auto-promote-timeout` - range[`0-600`]
     * - `DrbdOptions/Resource/max-io-depth` - range[`4-4294967295`]
     * - `DrbdOptions/Resource/quorum` - enum [`1-32`]
     *     * off
     *     * majority
     *     * all
     *
     * - `DrbdOptions/Resource/on-no-quorum` - enum
     *     * io-error
     *     * suspend-io
     *
     * - `DrbdOptions/Resource/quorum-minimum-redundancy` - enum [`1-32`]
     *     * off
     *     * majority
     *     * all
     *
     * - `DrbdOptions/Net/transport` - string
     * - `DrbdOptions/Net/protocol` - enum
     *     * A
     *     * B
     *     * C
     *
     * - `DrbdOptions/Net/timeout` - range[`1-600`]
     * - `DrbdOptions/Net/max-epoch-size` - range[`1-20000`]
     * - `DrbdOptions/Net/connect-int` - range[`1-120`]
     * - `DrbdOptions/Net/ping-int` - range[`1-120`]
     * - `DrbdOptions/Net/sndbuf-size` - range[`0-10485760`]
     * - `DrbdOptions/Net/rcvbuf-size` - range[`0-10485760`]
     * - `DrbdOptions/Net/ko-count` - range[`0-200`]
     * - `DrbdOptions/Net/allow-two-primaries` - boolean
     * - `DrbdOptions/Net/cram-hmac-alg` - string
     * - `DrbdOptions/Net/shared-secret` - string
     * - `DrbdOptions/Net/after-sb-0pri` - enum
     *     * disconnect
     *     * discard-younger-primary
     *     * discard-older-primary
     *     * discard-zero-changes
     *     * discard-least-changes
     *     * discard-local
     *     * discard-remote
     *
     * - `DrbdOptions/Net/after-sb-1pri` - enum
     *     * disconnect
     *     * consensus
     *     * discard-secondary
     *     * call-pri-lost-after-sb
     *     * violently-as0p
     *
     * - `DrbdOptions/Net/after-sb-2pri` - enum
     *     * disconnect
     *     * call-pri-lost-after-sb
     *     * violently-as0p
     *
     * - `DrbdOptions/Net/always-asbp` - boolean
     * - `DrbdOptions/Net/rr-conflict` - enum
     *     * disconnect
     *     * call-pri-lost
     *     * violently
     *     * retry-connect
     *
     * - `DrbdOptions/Net/ping-timeout` - range[`1-300`]
     * - `DrbdOptions/Net/data-integrity-alg` - string
     * - `DrbdOptions/Net/tcp-cork` - boolean
     * - `DrbdOptions/Net/on-congestion` - enum
     *     * block
     *     * pull-ahead
     *     * disconnect
     *
     * - `DrbdOptions/Net/congestion-fill` - range[`0-20971520`]
     * - `DrbdOptions/Net/congestion-extents` - range[`67-65534`]
     * - `DrbdOptions/Net/csums-alg` - string
     * - `DrbdOptions/Net/csums-after-crash-only` - boolean
     * - `DrbdOptions/Net/verify-alg` - string
     * - `DrbdOptions/Net/use-rle` - boolean
     * - `DrbdOptions/Net/socket-check-timeout` - range[`0-300`]
     * - `DrbdOptions/Net/fencing` - enum
     *     * dont-care
     *     * resource-only
     *     * resource-and-stonith
     *
     * - `DrbdOptions/Net/max-buffers` - range[`32-131072`]
     * - `DrbdOptions/Net/allow-remote-read` - boolean
     * - `DrbdOptions/Handlers/after-resync-target` - string
     * - `DrbdOptions/Handlers/before-resync-target` - string
     * - `DrbdOptions/Handlers/before-resync-source` - string
     * - `DrbdOptions/Handlers/out-of-sync` - string
     * - `DrbdOptions/Handlers/quorum-lost` - string
     * - `DrbdOptions/Handlers/fence-peer` - string
     * - `DrbdOptions/Handlers/unfence-peer` - string
     * - `DrbdOptions/Handlers/initial-split-brain` - string
     * - `DrbdOptions/Handlers/local-io-error` - string
     * - `DrbdOptions/Handlers/pri-lost` - string
     * - `DrbdOptions/Handlers/pri-lost-after-sb` - string
     * - `DrbdOptions/Handlers/pri-on-incon-degr` - string
     * - `DrbdOptions/Handlers/split-brain` - string
     */
    post: operations['controllerPropertyModify'];
  };
  '/v1/controller/properties/{key}': {
    /** Delete a controller property */
    delete: operations['controllerPropertyDelete'];
  };
  '/v1/controller/properties/info': {
    /**
     * List all properties, including their names and descriptions, that can
     * be set for the LINSTOR controller.
     */
    get: {
      responses: {
        /**
         * A map where the key is the property name and the value is a
         * PropsInfo object describing the property.
         */
        200: {
          content: {
            'application/json': {
              [key: string]: components['schemas']['PropsInfo'];
            };
          };
        };
      };
    };
  };
  '/v1/controller/properties/info/all': {
    /**
     * List all properties, including their names and descriptions, that can
     * be set for any entity in the cluster. This includes the controller,
     * resource definitions, resource groups, connections, volumes, etc.
     */
    get: {
      responses: {
        /**
         * A structure that maps entity types to a map of their properties.
         * The key is the entity type in uppercase. The value is a map
         * where the key is the property name and the value is a PropsInfo
         * object describing the property.
         */
        200: {
          content: {
            'application/json': {
              [key: string]: {
                [key: string]: components['schemas']['PropsInfo'];
              };
            };
          };
        };
      };
    };
  };
  '/v1/controller/config': {
    /** Show Controller config */
    get: operations['ControllerConfig'];
    put: operations['CtrlSetConfig'];
  };
  '/v1/controller/backup/db': {
    /** create a h2 database backup. Currently only H2(embedded) db is working. */
    post: operations['controllerBackupDB'];
  };
  '/v1/controller/version': {
    /** Show Controller version info */
    get: operations['controllerVersion'];
  };
  '/v1/resource-definitions/{resource}/drbd-proxy': {
    /**
     * Sets or modifies properties
     *
     * Possible properties are:
     * - `DrbdOptions/Proxy/memlimit` - range[`16777216-9223372036854775807`]
     * - `DrbdOptions/Proxy/read-loops` - range[`0-2147483647`]
     * - `DrbdOptions/Proxy/sndbuf-size` - range[`0-10485760`]
     * - `DrbdOptions/Proxy/rcvbuf-size` - range[`0-10485760`]
     * - `DrbdOptions/Proxy/ping-timeout` - range[`1-300`]
     * - `DrbdOptions/ProxyCompression/dict-size` - range[`4096-1610612736`]
     * - `DrbdOptions/ProxyCompression/lc` - range[`0-4`]
     * - `DrbdOptions/ProxyCompression/lp` - range[`0-4`]
     * - `DrbdOptions/ProxyCompression/pb` - range[`0-4`]
     * - `DrbdOptions/ProxyCompression/nice-len` - range[`0-273`]
     * - `DrbdOptions/ProxyCompression/mf` - enum
     *     * hc4
     *     * hc3
     *     * bt2
     *     * bt3
     *     * bt4
     *
     * - `DrbdOptions/ProxyCompression/mode` - enum
     *     * fast
     *     * normal
     *
     * - `DrbdOptions/ProxyCompression/depth` - range[`0-1000`]
     * - `DrbdOptions/ProxyCompression/level` - range[`1-9`]
     * - `DrbdOptions/ProxyCompression/contexts` - range[`1-253`]
     * - `DrbdOptions/ProxyCompression/fallback-to-zlib` - enum
     *     * off
     *     * on
     *
     * - `DrbdOptions/ProxyCompression/numa-threshold` - range[`0-253`]
     * - `DrbdOptions/ProxyCompression/level` - range[`1-9`]
     * - `DrbdOptions/ProxyCompression/level` - range[`1-22`]
     */
    put: operations['resourceDrbdProxyModify'];
  };
  '/v1/resource-definitions/{resource}/drbd-proxy/properties/info': {
    /**
     * List all properties, including their names and descriptions, that can
     * be set for DRBD proxy on a given resource definition.
     */
    get: {
      parameters: {
        path: {
          /** resource to use */
          resource: string;
        };
      };
      responses: {
        /**
         * A structure that maps the DBRD proxy configuration sections to their properties.
         * The key is the DRBD proxy configuration section The value is a map where the
         * key is the property name and the value is a PropsInfo object describing the
         * property.\
         * The following DRBD proxy configuration sections exist:
         * - DRBD_PROXY
         * - DRBD_PROXY_LZMA
         * - DRBD_PROXY_LZ4
         * - DRBD_PROXY_ZLIB
         * - DRBD_PROXY_ZSTD
         */
        200: {
          content: {
            'application/json': {
              [key: string]: components['schemas']['PropsInfo'];
            };
          };
        };
      };
    };
  };
  '/v1/resource-definitions/{resource}/drbd-proxy/enable/{node_a}/{node_b}': {
    /** Enables a drbd proxy on a node connection */
    post: operations['resourceDrbdProxyEnable'];
  };
  '/v1/resource-definitions/{resource}/drbd-proxy/disable/{node_a}/{node_b}': {
    /** Disables a drbd proxy on a node connection */
    post: operations['resourceDrbdProxyDisable'];
  };
  '/v1/encryption/passphrase': {
    put: operations['encryptionPassphraseModify'];
    post: operations['encryptionPassphraseCreate'];
    patch: operations['encryptionPassphraseEnter'];
  };
  '/v1/error-reports': {
    /** List all error reports */
    get: operations['errorReportList'];
    /** Deletes a range of error-reports */
    patch: operations['errorReportDelete'];
  };
  '/v1/stats/error-reports': {
    /** Returns a error report stats object. */
    get: operations['errorReportStats'];
  };
  '/v1/error-reports/{reportid}': {
    /** Query the specified reportid */
    get: operations['errorReportShow'];
    /** Deletes a single error-report */
    delete: operations['errorReportDeleteSingle'];
  };
  '/v1/key-value-store': {
    /** List all known key value store instances */
    get: operations['keyValueStoresList'];
  };
  '/v1/key-value-store/{instance}': {
    /** List all known key value store instances */
    get: operations['keyValueStoreList'];
    /** Modify a key value store */
    put: operations['keyValueStoreModify'];
    /** Delete a key value store */
    delete: operations['keyValueStoreDelete'];
  };
  '/v1/query-max-volume-size': {
    /** Query the maximum possible volume size storage pools */
    options: operations['queryMaxVolumeSize'];
  };
  '/v1/view/resources': {
    /** This REST-resource should be used if you want to get an overview of all resources with their volumes. */
    get: operations['viewResources'];
  };
  '/v1/view/storage-pools': {
    /** This REST-resource should be used if you want to get an overview of all storage pools. */
    get: operations['viewStoragePools'];
  };
  '/v1/view/snapshots': {
    /** This REST-resource should be used if you want to get an overview of all snapshots. */
    get: operations['viewSnapshots'];
  };
  '/v1/view/snapshot-shippings': {
    get: operations['viewSnapshotShippings'];
  };
  '/v1/view/schedules-by-resource': {
    /** list all schedule-remote-rscDfn-triples */
    get: {
      parameters: {
        query: {
          /** filter by rsc-name */
          rsc?: string;
          /** filter by remote-name */
          remote?: string;
          /** filter by schedule-name */
          schedule?: string;
          /** only list active schedules */
          'active-only'?: boolean;
        };
      };
      responses: {
        /** list of triples */
        200: {
          content: {
            'application/json': components['schemas']['ScheduledRscsList'];
          };
        };
      };
    };
  };
  '/v1/schedules-by-resource/{rscName}': {
    /** list the details of all schedules set on a specific rscDfn */
    get: {
      parameters: {
        path: {
          /** the rscDfn you want to see the schedule-details from */
          rscName: string;
        };
      };
      responses: {
        /** list of schedule-details */
        200: {
          content: {
            'application/json': components['schemas']['ScheduleDetailsList'];
          };
        };
      };
    };
  };
  '/v1/stats/resources': {
    /** Returns a resource stats object. */
    get: operations['resourcesStats'];
  };
  '/v1/stats/storage-pools': {
    /** Returns a storage pool stats object. */
    get: operations['storagePoolsStats'];
  };
  '/v1/physical-storage': {
    /** Gives a grouped list of physical storage that can be turned into a LINSTOR storage-pool */
    get: operations['viewPhysicaStorage'];
  };
  '/v1/physical-storage/{node}': {
    /** Gives a complete list of physical storage that can be turned into a LINSTOR storage-pool. */
    get: operations['getPhysicalStorage'];
    /**
     * Creates a LVM/LVM-thin, ZFS pool on the given device and if supported VDO(optional) under it.
     * logcal_size_kib parameter is only needed if LVM-thin or vdo is used.
     * Also note VDO can only used with LVM-fat.
     */
    post: operations['createDevicePool'];
  };
  '/v1/sos-report': {
    get: operations['createSOSReport'];
  };
  '/v1/sos-report/download': {
    get: operations['downloadSOSReport'];
  };
  '/v1/remotes/{remote_name}/backups': {
    /** list all backups in a single bucket */
    get: {
      parameters: {
        path: {
          /** The remote to list the backups from */
          remote_name: string;
        };
        query: {
          /** Only show backups of this resource */
          rsc_name?: string;
          /** Only show backups with this snapshot name */
          snap_name?: string;
        };
      };
      responses: {
        /** list of backups */
        200: {
          content: {
            'application/json': components['schemas']['BackupList'];
          };
        };
      };
    };
    /** create and ship a full backup to the target system */
    post: {
      parameters: {
        path: {
          /** The remote to ship the backups to */
          remote_name: string;
        };
      };
      responses: {
        /** backup created and shipping started */
        200: {
          content: {
            'application/json': components['schemas']['ApiCallRcList'];
          };
        };
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['BackupCreate'];
        };
      };
    };
    /** delete the specified backups */
    delete: {
      parameters: {
        path: {
          /** The remote to delete the backups from */
          remote_name: string;
        };
        query: {
          /** ID of the specific backup to be deleted */
          id?: string;
          /** ID prefix of possibly multiple backups to be deleted */
          id_prefix?: string;
          /** deletes the specified backup(s) and all backups depending on it */
          cascading?: boolean;
          /** deletes all backups that were made before the given timestamp */
          timestamp?: string;
          /** deletes all backups made from the specified resource */
          resource_name?: string;
          /** deletes all backups made from the specified node */
          node_name?: string;
          /** deletes all backups made from the current cluster */
          all_local_cluster?: boolean;
          /** deletes ALL backups */
          all?: boolean;
          /** deletes the backup associated with the s3key if it fits the naming-criteria */
          s3key?: string;
          /** deletes the s3key - regardless of whether it is a backup or not */
          s3key_force?: string;
          /** does not delete anything but returns an ApiCallRc with all entries that would be deleted */
          dryrun?: boolean;
          /** makes sure the snapshots the backups originated from are not deleted */
          keep_snaps?: boolean;
        };
      };
      responses: {
        /** backups deleted or error messages */
        200: {
          content: {
            'application/json': components['schemas']['ApiCallRcList'];
          };
        };
      };
    };
  };
  '/v1/remotes/{remote_name}/backups/restore': {
    /** restore the specified backups */
    post: {
      parameters: {
        path: {
          /** The remote to restore the backup from */
          remote_name: string;
        };
      };
      responses: {
        /** backup restore started or error messages */
        200: {
          content: {
            'application/json': components['schemas']['ApiCallRcList'];
          };
        };
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['BackupRestore'];
        };
      };
    };
  };
  '/v1/remotes/{remote_name}/backups/abort': {
    /** abort all backups of the given resource */
    post: {
      parameters: {
        path: {
          /** The remote to abort the backups from */
          remote_name: string;
        };
      };
      responses: {
        /** backups aborted or error messages */
        200: {
          content: {
            'application/json': components['schemas']['ApiCallRcList'];
          };
        };
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['BackupAbort'];
        };
      };
    };
  };
  '/v1/remotes/{remote_name}/backups/ship': {
    /** ships a backup from one Linstor cluster to another */
    post: {
      parameters: {
        path: {
          /** The remote to ship the backup to */
          remote_name: string;
        };
      };
      responses: {
        /** shippment has started or error messages */
        200: {
          content: {
            'application/json': components['schemas']['ApiCallRcList'];
          };
        };
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['BackupShip'];
        };
      };
    };
  };
  '/v1/remotes/{remote_name}/backups/info': {
    /** get info about the storpools a backup uses and the size it needs */
    post: {
      parameters: {
        path: {
          /** The remote to get the info from */
          remote_name: string;
        };
      };
      responses: {
        /** successfully get the info */
        200: {
          content: {
            'application/json': components['schemas']['BackupInfo'];
          };
        };
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['BackupInfoRequest'];
        };
      };
    };
  };
  '/v1/remotes/{remote_name}/backups/schedule/{schedule_name}/enable': {
    /** enable backups to be scheduled to a specific remote */
    put: {
      parameters: {
        path: {
          /** The remote to ship the backup to */
          remote_name: string;
          /** the schedule with which the backup should be shipped */
          schedule_name: string;
        };
      };
      responses: {
        /** backup schedule enabled sucessfully or error messages */
        200: {
          content: {
            'application/json': components['schemas']['ApiCallRcList'];
          };
        };
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['BackupSchedule'];
        };
      };
    };
  };
  '/v1/remotes/{remote_name}/backups/schedule/{schedule_name}/disable': {
    /** disable backups to be scheduled to a specific remote */
    put: {
      parameters: {
        path: {
          /** The remote to ship the backup to */
          remote_name: string;
          /** the schedule with which the backup is being shipped */
          schedule_name: string;
        };
      };
      responses: {
        /** backup schedule disabled sucessfully or error messages */
        200: {
          content: {
            'application/json': components['schemas']['ApiCallRcList'];
          };
        };
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['BackupSchedule'];
        };
      };
    };
  };
  '/v1/remotes/{remote_name}/backups/schedule/{schedule_name}/delete': {
    /** delete backups to be scheduled to a specific remote */
    delete: {
      parameters: {
        path: {
          /** The remote to ship the backup to */
          remote_name: string;
          /** the schedule with which the backup is being shipped */
          schedule_name: string;
        };
        query: {
          /** the resource definition the schedule is assigned to */
          rsc_dfn_name?: string;
          /** the resource group the schedule is assigned to */
          rsc_grp_name?: string;
        };
      };
      responses: {
        /** backup schedule deleted sucessfully or error messages */
        200: {
          content: {
            'application/json': components['schemas']['ApiCallRcList'];
          };
        };
      };
    };
  };
  '/v1/events/drbd/promotion': {
    /** Notifies clients about changes in may_promote of resources */
    get: {
      responses: {
        /** drbd promotion event stream */
        200: {
          content: {
            'text/event-stream': components['schemas']['inline_response_200'];
          };
        };
      };
    };
  };
  '/v1/events/nodes': {
    /** Notifies clients about changes with nodes */
    get: {
      responses: {
        /** linstor node events */
        200: {
          content: {
            'text/event-stream': components['schemas']['inline_response_200_1'];
          };
        };
      };
    };
  };
  '/v1/vendor/seagate/exos/defaults': {
    /** Lists default setting for all EXOS enclosures */
    get: {
      responses: {
        /** List of default settings */
        200: {
          content: {
            'application/json': components['schemas']['ExosDefaults'][];
          };
        };
      };
    };
    /** Sets or modifies default username / password for EXOS enclosures */
    put: operations['exosModifyDefault'];
  };
  '/v1/vendor/seagate/exos/enclosures': {
    /** Lists EXOS enclosures including controller IP and health status */
    get: {
      parameters: {
        query: {
          /** Force recaching before response */
          nocache?: boolean;
        };
      };
      responses: {
        /** List of EXOS enclosures */
        200: {
          content: {
            'application/json': components['schemas']['ExosEnclosureHealth'][];
          };
        };
      };
    };
    /** Creates a new enclosure unless it already exists */
    post: operations['exosCreate'];
  };
  '/v1/vendor/seagate/exos/enclosures/{enclosure}': {
    /** Modifies an existing enclosure */
    put: operations['exosModify'];
    /** Deletes an existing enclosure */
    delete: operations['exosDelete'];
  };
  '/v1/vendor/seagate/exos/{enclosure}/events': {
    /** Lists the most current X events */
    get: operations['exosDescribe'];
  };
  '/v1/vendor/seagate/exos/map': {
    /** Lists the connection-mesh of EXOS Ports to Linstor Nodes */
    get: operations['exosMap'];
  };
  '/v1/remotes': {
    /** list of all known remotes on this cluster */
    get: {
      responses: {
        /** list of remotes */
        200: {
          content: {
            'application/json': components['schemas']['RemoteList'][];
          };
        };
      };
    };
    /** delete the given remote */
    delete: {
      parameters: {
        query: {
          /** name of the remote */
          remote_name: string;
        };
      };
      responses: {
        /** remote successfully deleted */
        200: {
          content: {
            'application/json': components['schemas']['ApiCallRcList'];
          };
        };
      };
    };
  };
  '/v1/remotes/s3/{remoteName}': {
    /** modify an existing s3 remote */
    put: {
      parameters: {
        path: {
          /** name of the remote */
          remoteName: string;
        };
      };
      responses: {
        /** s3 remote modified */
        200: {
          content: {
            'application/json': components['schemas']['ApiCallRcList'];
          };
        };
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['S3Remote'];
        };
      };
    };
  };
  '/v1/remotes/s3': {
    /** list of all known s3 remotes on this cluster */
    get: {
      responses: {
        /** list of s3 remotes */
        200: {
          content: {
            'application/json': components['schemas']['S3Remote'][];
          };
        };
      };
    };
    /** Creates a new s3 remote unless it already exists */
    post: {
      responses: {
        /** s3 remote successfully created */
        200: {
          content: {
            'application/json': components['schemas']['ApiCallRcList'];
          };
        };
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['S3Remote'];
        };
      };
    };
  };
  '/v1/remotes/linstor': {
    /** list of all known linstor remotes on this cluster */
    get: {
      responses: {
        /** list of linstor remotes */
        200: {
          content: {
            'application/json': components['schemas']['LinstorRemote'][];
          };
        };
      };
    };
    /** Creates a new linstor remote unless it already exists */
    post: {
      responses: {
        /** linstor remote successfully created */
        200: {
          content: {
            'application/json': components['schemas']['ApiCallRcList'];
          };
        };
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['LinstorRemote'];
        };
      };
    };
  };
  '/v1/remotes/linstor/{remoteName}': {
    /** modify an existing linstor remote */
    put: {
      parameters: {
        path: {
          /** name of the remote */
          remoteName: string;
        };
      };
      responses: {
        /** linstor remote modified */
        200: {
          content: {
            'application/json': components['schemas']['ApiCallRcList'];
          };
        };
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['LinstorRemote'];
        };
      };
    };
  };
  '/v1/remotes/ebs': {
    /** list of all known EBS remotes on this cluster */
    get: {
      responses: {
        /** list of EBS remotes */
        200: {
          content: {
            'application/json': components['schemas']['EbsRemote'][];
          };
        };
      };
    };
    /** Creates a new EBS remote unless it already exists */
    post: {
      responses: {
        /** EBS remote successfully created */
        200: {
          content: {
            'application/json': components['schemas']['ApiCallRcList'];
          };
        };
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['EbsRemote'];
        };
      };
    };
  };
  '/v1/remotes/ebs/{remoteName}': {
    /** modify an existing EBS remote */
    put: {
      parameters: {
        path: {
          /** name of the remote */
          remoteName: string;
        };
      };
      responses: {
        /** EBS remote modified */
        200: {
          content: {
            'application/json': components['schemas']['ApiCallRcList'];
          };
        };
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['EbsRemote'];
        };
      };
    };
  };
  '/v1/schedules': {
    /** list of all known schedules on this cluster */
    get: {
      responses: {
        /** list of schedules */
        200: {
          content: {
            'application/json': components['schemas']['ScheduleList'];
          };
        };
      };
    };
    /** Creates a new schedule unless it already exists */
    post: {
      responses: {
        /** schedule successfully created */
        200: {
          content: {
            'application/json': components['schemas']['ApiCallRcList'];
          };
        };
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['Schedule'];
        };
      };
    };
  };
  '/v1/schedules/{scheduleName}': {
    /** modify an existing schedule */
    put: {
      parameters: {
        path: {
          /** name of the schedule */
          scheduleName: string;
        };
      };
      responses: {
        /** schedule modified */
        200: {
          content: {
            'application/json': components['schemas']['ApiCallRcList'];
          };
        };
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['ScheduleModify'];
        };
      };
    };
    /** delete the given schedule */
    delete: {
      parameters: {
        path: {
          /** name of the schedule */
          scheduleName: string;
        };
      };
      responses: {
        /** schedule successfully deleted */
        200: {
          content: {
            'application/json': components['schemas']['ApiCallRcList'];
          };
        };
      };
    };
  };
  '/v1/files': {
    /**
     * Get a list of previously registered external files.
     * File contents are not included, unless the "content" query parameter
     * is explicitly set to true.
     */
    get: {
      parameters: {
        query: {
          /** Include file content in response. If not given, defaults to false. */
          content?: boolean;
        };
      };
      responses: {
        /** List of registered external files */
        200: {
          content: {
            'application/json': components['schemas']['ExternalFile'][];
          };
        };
      };
    };
  };
  '/v1/files/{extFileName}': {
    /** Shows the requested external file including its content */
    get: {
      parameters: {
        path: {
          /** Name of an external file. Must be an absolute path in URL-encoding */
          extFileName: string;
        };
      };
      responses: {
        /** shows the requested external file including its content */
        200: {
          content: {
            'application/json': components['schemas']['ExternalFile'];
          };
        };
      };
    };
    /** Register or modify a previously registered external file */
    put: {
      parameters: {
        path: {
          /** Name of an external file. Must be an absolute path in URL-encoding */
          extFileName: string;
        };
      };
      responses: {
        /** external file registered or modified */
        200: {
          content: {
            'application/json': components['schemas']['ApiCallRcList'];
          };
        };
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['ExternalFile'];
        };
      };
    };
    /**
     * Deletes the given external file. This effectively also deletes the file
     * on all satellites
     */
    delete: {
      parameters: {
        path: {
          /** Name of an external file. Must be an absolute path in URL-encoding */
          extFileName: string;
        };
      };
      responses: {
        /** File successfully deleted */
        200: {
          content: {
            'application/json': components['schemas']['ApiCallRcList'];
          };
        };
      };
    };
  };
}

export interface components {
  schemas: {
    /** @description Common api reply structure */
    ApiCallRc: {
      /**
       * Format: int64
       * @description A masked error number
       */
      ret_code: number;
      /** @example Operation result. */
      message: string;
      /** @description Cause of the error */
      cause?: string;
      /** @description Details to the error message */
      details?: string;
      /** @description Possible correction options */
      correction?: string;
      /** @description List of error report ids related to this api call return code. */
      error_report_ids?: string[];
      /** @description Map of objection that have been involved by the operation. */
      obj_refs?: { [key: string]: string };
    };
    ApiCallRcList: components['schemas']['ApiCallRc'][];
    Node: {
      /** @example nodeA */
      name: string;
      /**
       * @example Satellite
       * @enum {string}
       */
      type: 'Controller' | 'Satellite' | 'Combined' | 'Auxiliary' | 'Openflex_Target';
      flags?: string[];
      props?: components['schemas']['Properties'];
      net_interfaces?: components['schemas']['NetInterface'][];
      /**
       * @description Enum describing the current connection status.
       *
       * @example ONLINE
       * @enum {string}
       */
      connection_status?:
        | 'OFFLINE'
        | 'CONNECTED'
        | 'ONLINE'
        | 'VERSION_MISMATCH'
        | 'FULL_SYNC_FAILED'
        | 'AUTHENTICATION_ERROR'
        | 'UNKNOWN'
        | 'HOSTNAME_MISMATCH'
        | 'OTHER_CONTROLLER'
        | 'AUTHENTICATED'
        | 'NO_STLT_CONN';
      /**
       * @description unique object id
       * @example e8ef8d6b-17bc-42f0-9367-4aae40c78ecb
       */
      uuid?: string;
      storage_providers?: components['schemas']['ProviderKind'][];
      resource_layers?: components['schemas']['LayerType'][];
      unsupported_providers?: { [key: string]: string[] };
      unsupported_layers?: { [key: string]: string[] };
      /**
       * Format: int64
       * @description milliseconds since unix epoch in UTC
       */
      eviction_timestamp?: number;
    };
    NodeCreateEbs: {
      /** @example nodeA */
      name: string;
      /** @example EbsRemote */
      ebs_remote_name: string;
    };
    NodeModify: {
      node_type?: string;
      override_props?: components['schemas']['Properties'];
      delete_props?: string[];
      delete_namespaces?: string[];
    };
    NodeRestore: {
      delete_resources?: boolean;
      delete_snapshots?: boolean;
    };
    NetInterface: {
      /** @example default */
      name: string;
      /** @example 10.0.0.2 */
      address: string;
      /** @example 3366 */
      satellite_port?: number;
      /**
       * @example PLAIN
       * @enum {string}
       */
      satellite_encryption_type?: 'PLAIN' | 'SSL';
      /** @description Defines if this netinterface should be used for the satellite connection */
      is_active?: boolean;
      /**
       * @description unique object id
       * @example e8ef8d6b-17bc-42f0-9367-4aae40c78ecb
       */
      uuid?: string;
    };
    /** @description A string to string property map. */
    Properties: { [key: string]: string };
    /** @enum {string} */
    ProviderKind:
      | 'DISKLESS'
      | 'LVM'
      | 'LVM_THIN'
      | 'ZFS'
      | 'ZFS_THIN'
      | 'OPENFLEX_TARGET'
      | 'FILE'
      | 'FILE_THIN'
      | 'SPDK'
      | 'EBS_TARGET'
      | 'EBS_INIT';
    /**
     * @description Contains information about a storage pool.
     *
     * If state is `Error` check the storage pool object path for detailed error description:
     *
     *   /v1/nodes/{nodename}/storage-pools/{poolname}
     */
    StoragePool: {
      /** @example DfltStorPool */
      storage_pool_name: string;
      node_name?: string;
      provider_kind: components['schemas']['ProviderKind'];
      props?: components['schemas']['Properties'];
      /** @description read only map of static storage pool traits */
      static_traits?: { [key: string]: string };
      /**
       * Format: int64
       * @description Kibi - read only
       * @example 882894848
       */
      free_capacity?: number;
      /**
       * Format: int64
       * @description Kibi - read only
       * @example 1056964608
       */
      total_capacity?: number;
      /**
       * @description read only
       * @example drbd1:myfastpool
       */
      free_space_mgr_name?: string;
      /**
       * @description unique object id
       * @example e8ef8d6b-17bc-42f0-9367-4aae40c78ecb
       */
      uuid?: string;
      /** @description Currently known report messages for this storage pool */
      reports?: components['schemas']['ApiCallRc'][];
      /** @description true if the storage pool supports snapshots. false otherwise */
      supports_snapshots?: boolean;
      /** @description Name of the shared space or null if none given */
      shared_space?: string;
      /**
       * @description true if a shared storage pool uses linstor-external locking, like cLVM
       * @default false
       */
      external_locking?: boolean;
    };
    /** @enum {string} */
    LayerType: 'DRBD' | 'LUKS' | 'STORAGE' | 'NVME' | 'WRITECACHE' | 'CACHE' | 'BCACHE' | 'OPENFLEX';
    DrbdResourceDefinitionLayer: {
      resource_name_suffix?: string;
      /** Format: int32 */
      peer_slots?: number;
      /** Format: int32 */
      al_stripes?: number;
      /** Format: int64 */
      al_stripe_size_kib?: number;
      /**
       * Format: int32
       * @description used drbd port for this resource
       * @example 7000
       */
      port?: number;
      transport_type?: string;
      /**
       * @description drbd resource secret
       * @example 7sqCWjvGmwAiV5kzg3VF
       */
      secret?: string;
      down?: boolean;
    };
    OpenflexResourceDefinitionLayer: {
      resource_name_suffix?: string;
      nqn?: string;
    };
    ResourceDefinitionLayer: {
      type?: components['schemas']['LayerType'];
      data?:
        | components['schemas']['DrbdResourceDefinitionLayer']
        | components['schemas']['OpenflexResourceDefinitionLayer'];
    };
    ResourceDefinition: {
      /**
       * @default
       * @example rsc1
       */
      name?: string;
      external_name?: components['schemas']['ExternalName'];
      props?: components['schemas']['Properties'];
      flags?: string[];
      layer_data?: components['schemas']['ResourceDefinitionLayer'][];
      /**
       * @description unique object id
       * @example e8ef8d6b-17bc-42f0-9367-4aae40c78ecb
       */
      uuid?: string;
      /** @description name of the linked resource group, if there is a link */
      resource_group_name?: string;
      volume_definitions?: components['schemas']['VolumeDefinition'][];
    };
    ResourceDefinitionCreate: {
      /**
       * Format: int32
       * @description drbd port for resources
       */
      drbd_port?: number;
      /**
       * @description drbd resource secret
       * @example 7sqCWjvGmwAiV5kzg3VF
       */
      drbd_secret?: string;
      /**
       * Format: int32
       * @description drbd peer slot number
       */
      drbd_peer_slots?: number;
      /** @example IP */
      drbd_transport_type?: string;
      resource_definition: components['schemas']['ResourceDefinition'];
    };
    ResourceDefinitionModify: {
      override_props?: components['schemas']['Properties'];
      delete_props?: string[];
      delete_namespaces?: string[];
      /**
       * Format: int32
       * @description drbd port for resources
       */
      drbd_port?: number;
      /**
       * Format: int32
       * @description drbd peer slot number
       */
      drbd_peer_slots?: number;
      layer_stack?: components['schemas']['LayerType'][];
      /** @description change resource group to the given group name */
      resource_group?: string;
    };
    DrbdVolumeDefinition: {
      resource_name_suffix?: string;
      /** Format: int32 */
      volume_number?: number;
      /** Format: int32 */
      minor_number?: number;
    };
    VolumeDefinitionLayer: {
      type: components['schemas']['LayerType'];
      data?: components['schemas']['DrbdVolumeDefinition'];
    };
    VolumeDefinition: {
      /** Format: int32 */
      volume_number?: number;
      /**
       * Format: int64
       * @description Size of the volume in Kibi.
       */
      size_kib: number;
      props?: components['schemas']['Properties'];
      flags?: string[];
      layer_data?: components['schemas']['VolumeDefinitionLayer'][];
      /**
       * @description unique object id
       * @example e8ef8d6b-17bc-42f0-9367-4aae40c78ecb
       */
      uuid?: string;
    };
    VolumeDefinitionCreate: {
      volume_definition: components['schemas']['VolumeDefinition'];
      /** Format: int32 */
      drbd_minor_number?: number;
    };
    VolumeDefinitionModify: {
      /** Format: int64 */
      size_kib?: number;
      override_props?: components['schemas']['Properties'];
      delete_props?: string[];
      delete_namespaces?: string[];
      /**
       * @description To add a flag just specify the flag name, to remove a flag prepend it with a '-'.
       *
       * Flags:
       *   * GROSS_SIZE
       */
      flags?: string[];
    };
    DrbdResource: {
      drbd_resource_definition?: components['schemas']['DrbdResourceDefinitionLayer'];
      /** Format: int32 */
      node_id?: number;
      /** Format: int32 */
      peer_slots?: number;
      /** Format: int32 */
      al_stripes?: number;
      /** Format: int64 */
      al_size?: number;
      flags?: string[];
      drbd_volumes?: components['schemas']['DrbdVolume'][];
      connections?: { [key: string]: components['schemas']['DrbdConnection'] };
      /** Format: int32 */
      promotion_score?: number;
      may_promote?: boolean;
    };
    StorageResource: {
      storage_volumes?: components['schemas']['StorageVolume'][];
    };
    LUKSResource: {
      luks_volumes?: components['schemas']['LUKSVolume'][];
    };
    NVMEResource: {
      nvme_volumes?: components['schemas']['NVMEVolume'][];
    };
    OpenflexResource: {
      openflex_resource_definition?: components['schemas']['OpenflexResourceDefinitionLayer'];
      openflex_volumes?: components['schemas']['OpenflexVolume'][];
    };
    WritecacheResource: {
      writecache_volumes?: components['schemas']['WritecacheVolume'][];
    };
    CacheResource: {
      cache_volumes?: components['schemas']['CacheVolume'][];
    };
    BCacheResource: {
      bcache_volumes?: components['schemas']['BCacheVolume'][];
    };
    ResourceLayer: {
      children?: components['schemas']['ResourceLayer'][];
      resource_name_suffix?: string;
      type?: components['schemas']['LayerType'];
      drbd?: components['schemas']['DrbdResource'];
      luks?: components['schemas']['LUKSResource'];
      storage?: components['schemas']['StorageResource'];
      nvme?: components['schemas']['NVMEResource'];
      openflex?: components['schemas']['OpenflexResource'];
      writecache?: components['schemas']['WritecacheResource'];
      cache?: components['schemas']['CacheResource'];
      bcache?: components['schemas']['BCacheResource'];
    };
    ResourceState: {
      in_use?: boolean;
    };
    DrbdConnection: {
      connected?: boolean;
      /**
       * @description DRBD connection status
       * @example Connected
       * @enum {string}
       */
      message?:
        | 'StandAlone'
        | 'Disconnecting'
        | 'Unconnected'
        | 'Timeout'
        | 'BrokenPipe'
        | 'NetworkFailure'
        | 'ProtocolError'
        | 'Connecting'
        | 'TearDown'
        | 'Connected'
        | 'Unknown';
    };
    Resource: {
      /** @example rsc1 */
      name?: string;
      /** @example nodeA */
      node_name?: string;
      props?: components['schemas']['Properties'];
      flags?: string[];
      layer_object?: components['schemas']['ResourceLayer'];
      state?: components['schemas']['ResourceState'];
      /**
       * @description unique object id
       * @example e8ef8d6b-17bc-42f0-9367-4aae40c78ecb
       */
      uuid?: string;
      /**
       * Format: int64
       * @description milliseconds since unix epoch in UTC
       */
      create_timestamp?: number;
    };
    ResourceWithVolumes: components['schemas']['Resource'] & {
      volumes?: components['schemas']['Volume'][];
      /**
       * @description shared space name of the data storage pool of the first volume of
       * the resource or empty if data storage pool is not shared
       */
      shared_name?: string;
    };
    ResourceCreate: {
      resource?: components['schemas']['Resource'];
      layer_list?: components['schemas']['LayerType'][];
      /** Format: int32 */
      drbd_node_id?: number;
    };
    ResourceMakeAvailable: {
      layer_list?: components['schemas']['LayerType'][];
      /**
       * @description if true resource will be created as diskful even if diskless would be possible
       * @default false
       */
      diskful?: boolean;
    };
    ResourceModify: {
      override_props?: components['schemas']['Properties'];
      delete_props?: string[];
      delete_namespaces?: string[];
    };
    VolumeModify: {
      override_props?: components['schemas']['Properties'];
      delete_props?: string[];
      delete_namespaces?: string[];
    };
    DrbdVolume: {
      drbd_volume_definition?: components['schemas']['DrbdVolumeDefinition'];
      /** @description drbd device path e.g. '/dev/drbd1000' */
      device_path?: string;
      /** @description block device used by drbd */
      backing_device?: string;
      meta_disk?: string;
      /** Format: int64 */
      allocated_size_kib?: number;
      /** Format: int64 */
      usable_size_kib?: number;
      /** @description String describing current volume state */
      disk_state?: string;
      /** @description Storage pool name used for external meta data; null for internal */
      ext_meta_stor_pool?: string;
    };
    LUKSVolume: {
      /** Format: int32 */
      volume_number?: number;
      /** @description block device path */
      device_path?: string;
      /** @description block device used by luks */
      backing_device?: string;
      /** Format: int64 */
      allocated_size_kib?: number;
      /** Format: int64 */
      usable_size_kib?: number;
      /** @description String describing current volume state */
      disk_state?: string;
      opened?: boolean;
    };
    StorageVolume: {
      /** Format: int32 */
      volume_number?: number;
      /** @description block device path */
      device_path?: string;
      /** Format: int64 */
      allocated_size_kib?: number;
      /** Format: int64 */
      usable_size_kib?: number;
      /** @description String describing current volume state */
      disk_state?: string;
    };
    NVMEVolume: {
      /** Format: int32 */
      volume_number?: number;
      /** @description block device path */
      device_path?: string;
      /** @description block device used by nvme */
      backing_device?: string;
      /** Format: int64 */
      allocated_size_kib?: number;
      /** Format: int64 */
      usable_size_kib?: number;
      /** @description String describing current volume state */
      disk_state?: string;
    };
    OpenflexVolume: {
      /** Format: int32 */
      volume_number?: number;
      /** @description block device path */
      device_path?: string;
      /** Format: int64 */
      allocated_size_kib?: number;
      /** Format: int64 */
      usable_size_kib?: number;
      /** @description String describing current volume state */
      disk_state?: string;
    };
    WritecacheVolume: {
      /** Format: int32 */
      volume_number?: number;
      /** @description block device path */
      device_path?: string;
      /** @description block device path used as cache device */
      device_path_cache?: string;
      /** Format: int64 */
      allocated_size_kib?: number;
      /** Format: int64 */
      usable_size_kib?: number;
      /** @description String describing current volume state */
      disk_state?: string;
    };
    CacheVolume: {
      /** Format: int32 */
      volume_number?: number;
      /** @description block device path */
      device_path?: string;
      /** @description block device path used as cache device */
      device_path_cache?: string;
      /** @description block device path used as meta device */
      device_meta_cache?: string;
      /** Format: int64 */
      allocated_size_kib?: number;
      /** Format: int64 */
      usable_size_kib?: number;
      /** @description String describing current volume state */
      disk_state?: string;
    };
    BCacheVolume: {
      /** Format: int32 */
      volume_number?: number;
      /** @description block device path */
      device_path?: string;
      /** @description block device path used as cache device */
      device_path_cache?: string;
      /** Format: int64 */
      allocated_size_kib?: number;
      /** Format: int64 */
      usable_size_kib?: number;
      /** @description String describing current volume state */
      disk_state?: string;
    };
    VolumeLayer: {
      type?: components['schemas']['LayerType'];
      data?:
        | components['schemas']['DrbdVolume']
        | components['schemas']['LUKSVolume']
        | components['schemas']['StorageVolume']
        | components['schemas']['NVMEVolume']
        | components['schemas']['WritecacheVolume']
        | components['schemas']['CacheVolume']
        | components['schemas']['BCacheVolume'];
    };
    Volume: {
      /** Format: int32 */
      volume_number?: number;
      storage_pool_name?: string;
      provider_kind?: components['schemas']['ProviderKind'];
      device_path?: string;
      /** Format: int64 */
      allocated_size_kib?: number;
      /** Format: int64 */
      usable_size_kib?: number;
      props?: components['schemas']['Properties'];
      flags?: string[];
      state?: components['schemas']['VolumeState'];
      layer_data_list?: components['schemas']['VolumeLayer'][];
      /**
       * @description unique object id
       * @example e8ef8d6b-17bc-42f0-9367-4aae40c78ecb
       */
      uuid?: string;
      reports?: components['schemas']['ApiCallRc'][];
    };
    VolumeState: {
      disk_state?: string;
    };
    ResourceGroup: {
      /**
       * @default
       * @example rscgrp1
       */
      name?: string;
      /** @default */
      description?: string;
      props?: components['schemas']['Properties'];
      select_filter?: components['schemas']['AutoSelectFilter'];
      /**
       * @description unique object id
       * @example e8ef8d6b-17bc-42f0-9367-4aae40c78ecb
       */
      uuid?: string;
    };
    ResourceGroupModify: {
      description?: string;
      override_props?: components['schemas']['Properties'];
      delete_props?: string[];
      delete_namespaces?: string[];
      select_filter?: components['schemas']['AutoSelectFilter'];
    };
    ResourceGroupSpawn: {
      /** @description name of the resulting resource-definition */
      resource_definition_name?: string;
      resource_definition_external_name?: components['schemas']['ExternalName'];
      /** @description sizes (in kib) of the resulting volume-definitions */
      volume_sizes?: number[];
      select_filter?: components['schemas']['AutoSelectFilter'];
      /**
       * @description If false, the length of the vlm_sizes has to match the number of volume-groups or an
       * error is returned.
       *
       * If true and there are more vlm_sizes than volume-groups, the additional volume-definitions
       * will simply have no pre-set properties (i.e. "empty" volume-definitions)
       * If true and there are less vlm_sizes than volume-groups, the additional volume-groups
       * won't be used.
       *
       * If the count of vlm_sizes matches the number of volume-groups, this "partial" parameter
       * has no effect.
       *
       * @default false
       */
      partial?: boolean;
      /**
       * @description If true, the spawn command will only create the resource-definition with the volume-definitions
       * but will not perform an auto-place, even if it is configured.
       *
       * @default false
       */
      definitions_only?: boolean;
    };
    VolumeGroup: {
      /** Format: int32 */
      volume_number?: number;
      props?: components['schemas']['Properties'];
      /**
       * @description unique object id
       * @example e8ef8d6b-17bc-42f0-9367-4aae40c78ecb
       */
      uuid?: string;
      flags?: string[];
    };
    VolumeGroupModify: {
      override_props?: components['schemas']['Properties'];
      /**
       * @description To add a flag just specify the flag name, to remove a flag prepend it with a '-'.
       *
       * Flags:
       *   * GROSS_SIZE
       */
      flags?: string[];
      delete_props?: string[];
      delete_namespaces?: string[];
    };
    ResourceGroupAdjust: {
      select_filter?: components['schemas']['AutoSelectFilter'];
    };
    AutoPlaceRequest: {
      /** @default false */
      diskless_on_remaining?: boolean;
      select_filter: components['schemas']['AutoSelectFilter'];
      layer_list?: components['schemas']['LayerType'][];
    };
    AutoSelectFilter: {
      /** Format: int32 */
      place_count?: number;
      /** Format: int32 */
      additional_place_count?: number;
      node_name_list?: string[];
      storage_pool?: string;
      storage_pool_list?: string[];
      storage_pool_diskless_list?: string[];
      not_place_with_rsc?: string[];
      not_place_with_rsc_regex?: string;
      replicas_on_same?: string[];
      replicas_on_different?: string[];
      layer_stack?: string[];
      provider_list?: string[];
      diskless_on_remaining?: boolean;
      diskless_type?: string;
      /**
       * Format: double
       * @description Multiplier of thin storage pool's free space
       */
      overprovision?: number;
    };
    Candidate: {
      /** @example DfltStorPool */
      storage_pool?: string;
      /**
       * Format: int64
       * @description maximum size in KiB
       * @example 3194880
       */
      max_volume_size_kib?: number;
      node_names?: string[];
      all_thin?: boolean;
    };
    MaxVolumeSizes: {
      candidates?: components['schemas']['Candidate'][];
      /** Format: double */
      default_max_oversubscription_ratio?: number;
    };
    ControllerPropsModify: {
      override_props?: components['schemas']['Properties'];
      delete_props?: string[];
      delete_namespaces?: string[];
    };
    ControllerConfig: {
      config?: components['schemas']['ControllerConfigConfig'];
      debug?: components['schemas']['ControllerConfigDebug'];
      log?: components['schemas']['ControllerConfigLog'];
      db?: components['schemas']['ControllerConfigDb'];
      http?: components['schemas']['ControllerConfigHttp'];
      https?: components['schemas']['ControllerConfigHttps'];
      ldap?: components['schemas']['ControllerConfigLdap'];
    };
    ControllerConfigConfig: {
      dir?: string;
    };
    ControllerConfigDebug: {
      console_enabled?: boolean;
    };
    ControllerConfigLog: {
      print_stack_trace?: boolean;
      directory?: string;
      level?: components['schemas']['LogLevel'];
      level_global?: components['schemas']['LogLevel'];
      level_linstor?: components['schemas']['LogLevel'];
      level_linstor_global?: components['schemas']['LogLevel'];
      rest_access_log_path?: string;
      /** @enum {string} */
      rest_access_mode?: 'APPEND' | 'ROTATE_HOURLY' | 'ROTATE_DAILY' | 'NO_LOG';
    };
    ControllerConfigDb: {
      connection_url?: string;
      ca_certificate?: string;
      client_certificate?: string;
      in_memory?: string;
      version_check_disabled?: boolean;
      etcd?: components['schemas']['ControllerConfigDbEtcd'];
      k8s?: components['schemas']['ControllerConfigDbK8s'];
    };
    ControllerConfigDbEtcd: {
      /** Format: int32 */
      operations_per_transaction?: number;
      prefix?: string;
    };
    ControllerConfigDbK8s: {
      /** Format: int32 */
      request_retries?: number;
    };
    ControllerConfigHttp: {
      enabled?: boolean;
      listen_address?: string;
      /** Format: int32 */
      port?: number;
    };
    ControllerConfigHttps: {
      enabled?: boolean;
      listen_address?: string;
      /** Format: int32 */
      port?: number;
    };
    ControllerConfigLdap: {
      enabled?: boolean;
      public_access_allowed?: boolean;
      uri?: string;
      dn?: string;
      search_base?: string;
      search_filter?: string;
    };
    /** @enum {string} */
    LogLevel: 'ERROR' | 'WARN' | 'INFO' | 'DEBUG' | 'TRACE';
    ControllerVersion: {
      version?: string;
      git_hash?: string;
      build_time?: string;
      rest_api_version?: string;
    };
    DatabaseBackupRequest: {
      backup_name?: string;
    };
    SatelliteConfig: {
      config?: components['schemas']['ControllerConfigConfig'];
      debug?: components['schemas']['ControllerConfigDebug'];
      log?: components['schemas']['SatelliteConfigLog'];
      stlt_override_node_name?: string;
      openflex?: boolean;
      remote_spdk?: boolean;
      ebs?: boolean;
      special_satellite?: boolean;
      drbd_keep_res_pattern?: string;
      net?: components['schemas']['SatelliteConfigNet'];
    };
    SatelliteConfigLog: {
      print_stack_trace?: boolean;
      directory?: string;
      level?: components['schemas']['LogLevel'];
      level_linstor?: components['schemas']['LogLevel'];
    };
    SatelliteConfigNet: {
      bind_address?: string;
      /** Format: int32 */
      port?: number;
      com_type?: string;
    };
    /**
     * @example {
     *   "info": "sets the c-plan-ahead parameter for a peer device",
     *   "prop_type": "range",
     *   "value": "(0 - 300)",
     *   "dflt": "20",
     *   "unit": "1/10 seconds"
     * }
     */
    PropsInfo: {
      info?: string;
      prop_type?: string;
      value?: string;
      dflt?: string;
      unit?: string;
    };
    /**
     * @example {
     *   "node_name": "Controller",
     *   "error_time": 1536827504594,
     *   "filename": "ErrorReport-5B9A15B7-00000-000000.log"
     * }
     */
    ErrorReport: {
      node_name?: string;
      /** Format: int64 */
      error_time: number;
      /**
       * @description Filename of the error report on the server.
       *
       * Format is:
       * ```ErrorReport-{instanceid}-{nodeid}-{sequencenumber}.log```
       */
      filename?: string;
      /** @description Contains the full text of the error report file. */
      text?: string;
      /** @description Which module this error occurred. */
      module?: string;
      /** @description Linstor version this error report was created. */
      version?: string;
      /** @description Peer client that was involved. */
      peer?: string;
      /** @description Exception that occurred */
      exception?: string;
      /** @description Exception message */
      exception_message?: string;
      /** @description Origin file of the exception */
      origin_file?: string;
      /** @description Origin method where the exception occurred */
      origin_method?: string;
      /**
       * Format: int32
       * @description Origin line number
       */
      origin_line?: number;
    };
    ErrorReportDelete: {
      /**
       * Format: int64
       * @description timestamp in millis start date to delete
       */
      since?: number;
      /**
       * Format: int64
       * @description timestamp in millis for the end date to delete
       */
      to?: number;
      /** @description on which nodes to delete error-reports, if empty/null all nodes */
      nodes?: string[];
      /** @description delete all error reports with the given exception */
      exception?: string;
      /** @description delete all error reports from the given version */
      version?: string;
      /** @description error report ids to delete */
      ids?: string[];
    };
    KeyValueStore: {
      /** @description name of the key value store */
      name?: string;
      props?: components['schemas']['Properties'];
    };
    KeyValueStoreModify: {
      override_props?: components['schemas']['Properties'];
      delete_props?: string[];
      delete_namespaces?: string[];
    };
    ResourceConnection: {
      /** @description source node of the connection */
      node_a?: string;
      /** @description target node of the connection */
      node_b?: string;
      props?: components['schemas']['Properties'];
      flags?: string[];
      port?: number;
    };
    ResourceConnectionModify: {
      override_props?: components['schemas']['Properties'];
      delete_props?: string[];
      delete_namespaces?: string[];
    };
    Snapshot: {
      name?: string;
      resource_name?: string;
      nodes?: string[];
      props?: components['schemas']['Properties'];
      flags?: string[];
      volume_definitions?: components['schemas']['SnapshotVolumeDefinition'][];
      /**
       * @description unique object id
       * @example e8ef8d6b-17bc-42f0-9367-4aae40c78ecb
       */
      uuid?: string;
      snapshots?: components['schemas']['SnapshotNode'][];
    };
    SnapshotShippingStatus: {
      snapshot?: components['schemas']['Snapshot'];
      from_node_name?: string;
      to_node_name?: string;
      /** @enum {string} */
      status?: 'Running' | 'Complete';
    };
    /** @description Actual snapshot data from a node */
    SnapshotNode: {
      /** @description Snapshot name this snapshots belongs to */
      snapshot_name?: string;
      /** @description Node name where this snapshot was taken */
      node_name?: string;
      /**
       * Format: int64
       * @description milliseconds since unix epoch in UTC
       */
      create_timestamp?: number;
      flags?: string[];
      /**
       * @description unique object id
       * @example e8ef8d6b-17bc-42f0-9367-4aae40c78ecb
       */
      uuid?: string;
    };
    SnapshotVolumeDefinition: {
      /** Format: int32 */
      volume_number?: number;
      /**
       * Format: int64
       * @description Volume size in KiB
       */
      size_kib?: number;
    };
    SnapshotRestore: {
      /**
       * @description Resource where to restore the snapshot
       * @example rsc2
       */
      to_resource: string;
      /** @description List of nodes where to place the restored snapshot */
      nodes?: string[];
    };
    SnapshotShipping: {
      /** @description Node where to ship the snapshot from */
      from_node: string;
      /** @description NetInterface of the source node */
      from_nic?: string;
      /** @description Node where to ship the snapshot */
      to_node: string;
      /** @description NetInterface of the destination node */
      to_nic?: string;
    };
    BackupList: {
      /** @description A list containing all entries found that are or could be from linstor */
      linstor?: { [key: string]: components['schemas']['Backup'] };
      other?: components['schemas']['BackupOther'];
    };
    Backup: {
      id: string;
      start_time?: string;
      /** Format: int64 */
      start_timestamp?: number;
      finished_time?: string;
      /** Format: int64 */
      finished_timestamp?: number;
      origin_rsc: string;
      origin_snap?: string;
      origin_node?: string;
      fail_messages?: string;
      vlms: components['schemas']['BackupVolumes'][];
      success?: boolean;
      shipping?: boolean;
      restorable?: boolean;
      s3?: components['schemas']['BackupS3'];
      based_on_id?: string;
    };
    BackupVolumes: {
      /** Format: int64 */
      vlm_nr: number;
      finished_time?: string;
      /** Format: int64 */
      finished_timestamp?: number;
      s3?: components['schemas']['BackupVolumesS3'];
    };
    BackupVolumesS3: {
      key?: string;
    };
    BackupS3: {
      meta_name?: string;
    };
    /** @description A map containing all other entries found that have no relation to linstor */
    BackupOther: {
      files?: string[];
    };
    BackupRestore: {
      src_rsc_name?: string;
      src_snap_name?: string;
      last_backup?: string;
      stor_pool_map?: { [key: string]: string };
      target_rsc_name: string;
      passphrase?: string;
      node_name: string;
      /** @default false */
      download_only?: boolean;
    };
    BackupCreate: {
      rsc_name: string;
      node_name?: string;
      snap_name?: string;
      incremental?: boolean;
    };
    BackupAbort: {
      rsc_name: string;
      restore?: boolean;
      create?: boolean;
    };
    BackupShip: {
      src_node_name?: string;
      src_rsc_name: string;
      dst_rsc_name: string;
      dst_node_name?: string;
      dst_net_if_name?: string;
      dst_stor_pool?: string;
      stor_pool_rename?: { [key: string]: string };
      /** @default false */
      download_only?: boolean;
      /** @default true */
      allow_incremental?: boolean;
    };
    BackupInfo: {
      rsc: string;
      full: string;
      snap?: string;
      latest: string;
      /** Format: int32 */
      count?: number;
      /** Format: int64 */
      dl_size_kib: number;
      /** Format: int64 */
      alloc_size_kib: number;
      storpools: components['schemas']['BackupInfoStorPool'][];
    };
    BackupInfoRequest: {
      src_rsc_name?: string;
      src_snap_name?: string;
      last_backup?: string;
      stor_pool_map?: { [key: string]: string };
      node_name?: string;
    };
    BackupInfoStorPool: {
      name: string;
      provider_kind?: components['schemas']['ProviderKind'];
      target_name?: string;
      /** Format: int64 */
      remaining_space_kib?: number;
      vlms: components['schemas']['BackupInfoVolume'][];
    };
    BackupInfoVolume: {
      name?: string;
      layer_type: components['schemas']['LayerType'];
      /** Format: int64 */
      dl_size_kib?: number;
      /** Format: int64 */
      alloc_size_kib?: number;
      /** Format: int64 */
      usable_size_kib?: number;
    };
    BackupSchedule: {
      rsc_name?: string;
      grp_name?: string;
      node_name?: string;
    };
    ScheduleDetailsList: {
      data?: components['schemas']['ScheduleDetails'][];
    };
    ScheduleDetails: {
      remote_name: string;
      schedule_name: string;
      ctrl?: boolean;
      rsc_grp?: boolean;
      rsc_dfn?: boolean;
    };
    ScheduledRscsList: {
      data?: components['schemas']['ScheduledRscs'][];
    };
    ScheduledRscs: {
      rsc_name: string;
      remote_name: string;
      schedule_name: string;
      /**
       * @description The reason for why this rscDfn has no active schedules.
       * If this is set, ignore all long and boolean parameters.
       */
      reason?: string;
      /**
       * Format: int64
       * @description The time at which the last scheduled shipping was shipped.
       * If negative, no scheduled shipping has happened yet.
       */
      last_snap_time?: number;
      /**
       * @description Whether the last shipping was incremental or not.
       * Ignore this value if last_snap_time is negative.
       */
      last_snap_inc?: boolean;
      /**
       * Format: int64
       * @description The time at which the next scheduled shipping will happen.
       * If negative, the shipping is currently running.
       */
      next_exec_time?: number;
      /**
       * @description Whether the next scheduled shipping will be incremental or not.
       * Ignore if next_exec_time is negative
       */
      next_exec_inc?: boolean;
      /**
       * Format: int64
       * @description The time at which the next scheduled full backup should happen.
       * If negative, the time could not be computed
       */
      next_planned_full?: number;
      /**
       * Format: int64
       * @description The time at which the next scheduled incremental backup should happen.
       * If negative, either there is no cron for incremental backups or
       * the time could not be computed
       */
      next_planned_inc?: number;
    };
    PassPhraseCreate: {
      new_passphrase?: string;
      old_passphrase?: string;
    };
    PassPhraseEnter: string;
    StoragePoolDefinition: {
      storage_pool_name?: string;
      props?: components['schemas']['Properties'];
    };
    StoragePoolDefinitionModify: {
      override_props?: components['schemas']['Properties'];
      delete_props?: string[];
      delete_namespaces?: string[];
    };
    DrbdProxyEnable: {
      /**
       * Format: int32
       * @description Proxy port to use (optional)
       */
      port?: number;
    };
    DrbdProxyModify: {
      override_props?: components['schemas']['Properties'];
      delete_props?: string[];
      /**
       * @description Compression type used by the proxy.
       *
       * @enum {string}
       */
      compression_type?: 'none' | 'zlib' | 'lzma' | 'lz4';
      compression_props?: components['schemas']['Properties'];
    };
    PhysicalStorageNode: {
      /** Format: int64 */
      size?: number;
      rotational?: boolean;
      device?: string;
      model?: string;
      serial?: string;
      wwn?: string;
    };
    PhysicalStorage: {
      /** Format: int64 */
      size?: number;
      rotational?: boolean;
      nodes?: {
        [key: string]: components['schemas']['PhysicalStorageDevice'][];
      };
    };
    PhysicalStorageDevice: {
      device?: string;
      model?: string;
      serial?: string;
      wwn?: string;
    };
    /** @description This structure is used for create physical-storage */
    PhysicalStorageStoragePoolCreate: {
      /** @description Name of the linstor storage pool */
      name?: string;
      props?: components['schemas']['Properties'];
      /** @description Name of the shared space */
      shared_space?: string;
      /**
       * @description true if a shared storage pool uses linstor-external locking, like cLVM
       * @default false
       */
      external_locking?: boolean;
    };
    /** @description If `with_storage_pool` is set a linstor storage pool will also be created using this device pool */
    PhysicalStorageCreate: {
      provider_kind: components['schemas']['ProviderKind'];
      device_paths: string[];
      /**
       * @description RAID level to use for pool.
       *
       * @default JBOD
       * @enum {string}
       */
      raid_level?: 'JBOD';
      pool_name?: string;
      /** @default false */
      vdo_enable?: boolean;
      /**
       * Format: int64
       * @default 0
       */
      vdo_slab_size_kib?: number;
      /**
       * Format: int64
       * @default 0
       */
      vdo_logical_size_kib?: number;
      with_storage_pool?: components['schemas']['PhysicalStorageStoragePoolCreate'];
      /**
       * @description initialize SED with a random password
       * @default false
       */
      sed?: boolean;
    };
    /** @description may-promote-change */
    EventMayPromoteChange: {
      resource_name?: string;
      node_name?: string;
      may_promote?: boolean;
    };
    EventNode: {
      node?: components['schemas']['Node'];
    };
    EventNodeModified: {
      old_node?: components['schemas']['Node'];
      new_node?: components['schemas']['Node'];
    };
    /** @description Default settings for EXOS enclosures */
    ExosDefaults: {
      username?: string;
      username_env?: string;
      password?: string;
      password_env?: string;
    };
    ExosDefaultsModify: components['schemas']['ExosDefaults'] & {
      /** @description A list of keys to unset. The keys have to exist in ExosDefaults */
      unset_keys?: string[];
    };
    /** @description EXOS enclosure name, controller IPs and health status */
    ExosEnclosureHealth: {
      name?: string;
      ctrl_a_ip?: string;
      ctrl_b_ip?: string;
      health?: string;
      health_reason?: string;
    };
    /** @description EXOS enclosure */
    ExosEnclosure: {
      name?: string;
      ctrl_a_ip?: string;
      ctrl_b_ip?: string;
      username?: string;
      username_env?: string;
      password?: string;
      password_env?: string;
    };
    /** @description EXOS event */
    ExosEnclosureEvent: {
      severity?: string;
      event_id?: string;
      controller?: string;
      time_stamp?: string;
      /** Format: int64 */
      time_stamp_numeric?: number;
      message?: string;
      additional_information?: string;
      recommended_action?: string;
    };
    ExosConnectionMap: {
      node_name?: string;
      enclosure_name?: string;
      connections?: string[];
    };
    /** @description External file which can be configured to be deployed by Linstor */
    ExternalFile: {
      /**
       * @description The path where the external file should be deployed on the node
       * @example /etc/some.conf
       */
      path?: string;
      /**
       * @description The contents of the file, in base64 encoding
       * @example SGVsbG8sIFdvcmxkIQo=
       */
      content?: string;
    };
    /** @description ToggleDisk optional payload data */
    ToggleDiskDiskful: {
      layer_list?: components['schemas']['LayerType'][];
    };
    /**
     * @description External name can be used to have native resource names.
     * If you need to store a non Linstor compatible resource name use this field
     * and Linstor will generate a compatible name.
     */
    ExternalName: string;
    /** @description Clone request object */
    ResourceDefinitionCloneRequest: {
      name?: string;
      external_name?: components['schemas']['ExternalName'];
      /**
       * @description If true Zfs will not use send/recv to clone, but instead
       * use a parent snapshot with clone, which cannot be deleted
       */
      use_zfs_clone?: boolean;
    };
    /** @description Clone request started object */
    ResourceDefinitionCloneStarted: {
      /**
       * @description Path for clone status
       * @example /v1/resource-definitions/testres/clone/clonedresource
       */
      location: string;
      /** @description name of the source resource */
      source_name: string;
      /** @description name of the clone resource */
      clone_name: string;
      messages?: components['schemas']['ApiCallRcList'];
    };
    /** @description Clone status object */
    ResourceDefinitionCloneStatus: {
      /**
       * @description CLONING -> indicates the resource is currently copying data
       * FAILED -> error occured while cloning, resource not usable
       * COMPLETE -> resource is ready to use
       *
       * @enum {string}
       */
      status: 'COMPLETE' | 'CLONING' | 'FAILED';
    };
    /** @description Clone status object */
    ResourceDefinitionSyncStatus: {
      /** @default false */
      synced_on_all: boolean;
    };
    RemoteList: {
      s3_remotes?: components['schemas']['S3Remote'][];
      linstor_remotes?: components['schemas']['LinstorRemote'][];
      ebs_remotes?: components['schemas']['EbsRemote'][];
    };
    S3Remote: {
      remote_name?: string;
      endpoint?: string;
      bucket?: string;
      region?: string;
      access_key?: string;
      secret_key?: string;
      /** @default false */
      use_path_style?: boolean;
    };
    LinstorRemote: {
      remote_name?: string;
      url?: string;
      passphrase?: string;
      cluster_id?: string;
    };
    EbsRemote: {
      remote_name?: string;
      endpoint?: string;
      region?: string;
      availability_zone?: string;
      access_key?: string;
      secret_key?: string;
    };
    ScheduleList: {
      data?: components['schemas']['Schedule'][];
    };
    Schedule: {
      schedule_name: string;
      full_cron: string;
      inc_cron?: string;
      /**
       * Format: int32
       * @description the number of snapshots that are basis for a full backup to keep locally
       */
      keep_local?: number;
      /**
       * Format: int32
       * @description the number of full backups to keep at the remote
       */
      keep_remote?: number;
      /**
       * @default SKIP
       * @enum {string}
       */
      on_failure?: 'SKIP' | 'RETRY';
      /**
       * Format: int32
       * @description how many times a failed backup should be retried if on_failure == RETRY
       */
      max_retries?: number;
    };
    ScheduleModify: {
      full_cron?: string;
      inc_cron?: string;
      /**
       * Format: int32
       * @description the number of snapshots that are basis for a full backup to keep locally
       */
      keep_local?: number;
      /**
       * Format: int32
       * @description the number of full backups to keep at the remote
       */
      keep_remote?: number;
      /** @enum {string} */
      on_failure?: 'SKIP' | 'RETRY';
      /**
       * Format: int32
       * @description how many times a failed backup should be retried if on_failure == RETRY
       */
      max_retries?: number;
    };
    NodeStats: {
      /** Format: int64 */
      count: number;
    };
    StoragePoolStats: {
      /** Format: int64 */
      count: number;
    };
    ResourceGroupStats: {
      /** Format: int64 */
      count: number;
    };
    ResourceDefinitionStats: {
      /** Format: int64 */
      count: number;
    };
    ResourceStats: {
      /** Format: int64 */
      count: number;
    };
    ErrorReportStats: {
      /** Format: int64 */
      count: number;
    };
    inline_response_200: {
      /** @enum {string} */
      event?: 'may-promote-change';
      data?: components['schemas']['EventMayPromoteChange'];
    };
    inline_response_200_1:
      | {
          /** @enum {string} */
          event?: 'node-create';
          data?: components['schemas']['EventNode'];
        }
      | {
          /** @enum {string} */
          event?: 'node-delete';
          data?: components['schemas']['EventNode'];
        }
      | {
          /** @enum {string} */
          event?: 'node-evacuate';
          data?: components['schemas']['EventNode'];
        }
      | {
          /** @enum {string} */
          event?: 'node-evicted';
          data?: components['schemas']['EventNode'];
        }
      | {
          /** @enum {string} */
          event?: 'node-restored';
          data?: components['schemas']['EventNode'];
        }
      | {
          /** @enum {string} */
          event?: 'node-modified';
          data?: components['schemas']['EventNodeModified'];
        };
  };
  responses: {
    /** invalid input, or request failed */
    InvalidInput: {
      content: {
        'application/json': components['schemas']['ApiCallRcList'];
      };
    };
    /** object not found */
    ObjectNotFound: {
      content: {
        'application/json': components['schemas']['ApiCallRcList'];
      };
    };
    /** operation failed */
    OperationFailed: {
      content: {
        'application/json': components['schemas']['ApiCallRc'];
      };
    };
  };
  parameters: {
    /** @description resource to use */
    Resource: string;
    /** @description resource clone name */
    ResourceClone: string;
    /** @description resource group to use */
    ResourceGroupName: string;
    /** @description node to use */
    Node: string;
    /** @description Filter only for the specified nodes, if not specified, no filtering. */
    Nodes: string[];
    /** @description Filter only for the specified resources, if not specified, no filtering. */
    Resources: string[];
    /** @description netinterface name to use */
    NetInterface: string;
    /** @description Storage pool to use */
    StoragePool: string;
    /** @description number of records to skip for pagination */
    Offset: number;
    /** @description maximum number of records to return */
    Limit: number;
    /** @description query data from cache if available */
    Cached: boolean;
    /** @description filter by given properties, full property path */
    Props: string[];
    /** @description source node of the connection */
    NodeA: string;
    /** @description target node of the connection */
    NodeB: string;
    /** @description Volume number of the definition */
    VolumeNumber: number;
    /** @description Unix epoch milliseconds */
    Since: number;
    /**
     * @description Name of an external file. Must be an absolute path in URL-encoding
     * @example %2Fetc%2Fsome.conf
     */
    ExternalFileName: string;
  };
}

export interface operations {
  /** Returns an array of all storage pool definitions */
  storagePoolDfnList: {
    parameters: {
      query: {
        /** number of records to skip for pagination */
        offset?: number;
        /** maximum number of records to return */
        limit?: number;
      };
    };
    responses: {
      /** Array of all storage pool definitions */
      200: {
        content: {
          'application/json': components['schemas']['StoragePoolDefinition'][];
        };
      };
    };
  };
  /** Adds a storage pool definition to Linstor */
  storagePoolDfnAdd: {
    responses: {
      /** storage pool definition created */
      201: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    /** Storage pool definition to add */
    requestBody: {
      content: {
        'application/json': components['schemas']['StoragePoolDefinition'];
      };
    };
  };
  /** Returns a specific storage pool definition */
  storagePoolDfnGet: {
    parameters: {
      path: {
        /** Storage pool to use */
        storagepool: string;
      };
    };
    responses: {
      /** Specified storage pool definition */
      200: {
        content: {
          'application/json': components['schemas']['StoragePoolDefinition'];
        };
      };
    };
  };
  /**
   * Sets or modifies properties
   *
   * Possible properties are:
   * - `MaxOversubscriptionRatio` - range[`1-1000`]
   */
  storPoolDfnModify: {
    parameters: {
      path: {
        /** Storage pool to use */
        storagepool: string;
      };
    };
    responses: {
      /** storage pool definition modified */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['StoragePoolDefinitionModify'];
      };
    };
  };
  /** Delete a storage pool definition from Linstor */
  storagePoolDefinitionDelete: {
    parameters: {
      path: {
        /** Storage pool to use */
        storagepool: string;
      };
    };
    responses: {
      /** storage pool definition deleted */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /** Returns an array of all nodes registered to Linstor. */
  nodeList: {
    parameters: {
      query: {
        /** Filter only for the specified nodes, if not specified, no filtering. */
        nodes?: string[];
        /** filter by given properties, full property path */
        props?: string[];
        /** number of records to skip for pagination */
        offset?: number;
        /** maximum number of records to return */
        limit?: number;
      };
    };
    responses: {
      /** Array of all node objects */
      200: {
        content: {
          'application/json': components['schemas']['Node'][];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
  };
  /**
   * Adds a node to Linstor
   *
   * If only one net-interface is specified and it is does not specify
   * a `satellite_port` it will apply the default port and `satellite_encryption_type`
   * for this net-interface.
   */
  nodeAdd: {
    responses: {
      /** node created */
      201: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    /** Node to add to Linstor */
    requestBody: {
      content: {
        'application/json': components['schemas']['Node'];
      };
    };
  };
  /** Returns a node stats object. */
  nodeStats: {
    responses: {
      /** Object stats */
      200: {
        content: {
          'application/json': components['schemas']['NodeStats'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
  };
  /**
   * Sets or modifies properties
   *
   * Possible properties are:
   * - `PrefNic` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Preferred network interface to use
   *
   * - `StorPoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Linstor storage pool name to use.
   *
   * - `StorPoolNameDrbdMeta` - regex[`^|.internal|[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Linstor storage pool name to use for external metadata.
   *
   * - `sys/fs/blkio_throttle_read` - long
   *
   *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device
   *
   * - `sys/fs/blkio_throttle_write` - long
   *
   *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device
   *
   * - `sys/fs/blkio_throttle_read_iops` - long
   *
   *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_iops_device
   *
   * - `sys/fs/blkio_throttle_write_iops` - long
   *
   *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_iops_device
   *
   * - `DrbdOptions/AutoEvictAfterTime` - long
   *
   *     Time a node can be offline before it is declared EVICTED in minutes
   *
   * - `DrbdOptions/AutoEvictAllowEviction` - boolean_true_false
   *
   *     If set to true on a node, it cannot be evicted anymore
   *
   * - `Writecache/PoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Linstor storage pool name for writecache
   *
   * - `Writecache/Size` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
   *
   *     Size of the writecache in % (0-100) or KiB otherwise
   *
   * - `Writecache/Options/StartSector` - long
   *
   *     offset from the start of cache device in 512-byte sectors
   *
   * - `Writecache/Options/HighWatermark` - long
   *
   *     start writeback when the number of used blocks reach this watermark
   *
   * - `Writecache/Options/LowWatermark` - long
   *
   *     stop writeback when the number of used blocks drops below this watermark
   *
   * - `Writecache/Options/WritebackJobs` - long
   *
   *     limit the number of blocks that are in flight during writeback. Setting this value reduces writeback throughput, but it may improve latency of read requests
   *
   * - `Writecache/Options/AutocommitBlocks` - long
   *
   *     when the application writes this amount of blocks without issuing the FLUSH request, the blocks are automatically commited
   *
   * - `Writecache/Options/AutocommitTime` - long
   *
   *     autocommit time in milliseconds. The data is automatically commited if this time passes and no FLUSH request is received
   *
   * - `Writecache/Options/Fua` - enum
   *
   *     "On" results in "fua" as argument, whereas the value "Off" results in "nofua" argument
   *
   *     * On
   *     * Off
   *
   * - `Writecache/Options/Additional` - string
   *
   *     Additional arguments passed through
   *
   * - `Cache/OpMode` - enum
   *
   *     Operation mode
   *
   *     * writeback
   *     * writethrough
   *     * passthrough
   *
   * - `Cache/MetaPool` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Name of the storage pool used for the cache metadata. If not specified, this will default to the CachePool property
   *
   * - `Cache/Metasize` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
   *
   *     Size of the cache in % (0-100) or KiB otherwise.
   *
   * - `Cache/CachePool` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Name of the storage pool used for the cache cache device
   *
   * - `Cache/Cachesize` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
   *
   *     Size of the cache in % (0-100) or KiB otherwise.
   *
   * - `Cache/Blocksize` - long
   *
   *     Block size
   *
   * - `Cache/Policy` - enum
   *
   *     Replacemant policy
   *
   *     * mq
   *     * smq
   *     * cleaner
   *
   * - `StorDriver/LvcreateOptions` - regex[`.*`]
   *
   *     Additional parameters added to every 'lvcreate ... ' command
   *
   * - `StorDriver/ZfscreateOptions` - regex[`.*`]
   *
   *     Additional parameters added to every 'zfs create ... ' command
   *
   * - `StorDriver/Openflex/ApiHost` - regex[`.+`]
   *
   *     Openflex API host name
   *
   * - `StorDriver/Openflex/ApiPort` - regex[`[0-9]+`]
   *
   *     Openflex API port
   *
   * - `StorDriver/Openflex/UserName` - regex[`.+`]
   *
   *     Openflex user name
   *
   * - `StorDriver/Openflex/UserPassword` - regex[`.+`]
   *
   *     Openflex password
   *
   * - `StorDriver/Openflex/StorDev` - regex[`.+`]
   *
   *     Openflex storage device
   *
   * - `StorDriver/Openflex/StorDevHost` - regex[`.+`]
   *
   *     Openflex storage device host
   *
   * - `StorDriver/Openflex/JobWaitDelay` - regex[`[0-9]+`]
   *
   *     Delay in milliseconds linstor waits between fetching the job status
   *
   * - `StorDriver/Openflex/JobWaitMaxCount` - regex[`[0-9]+`]
   *
   *     Maximum retries with wait delay until openflex fails
   *
   * - `Autoplacer/MaxThroughput` - long
   *
   *     The maximum throughput the given storage pool is capable of.
   *
   * - `DrbdProxy/AutoEnable` - boolean_true_false
   * - `Site` - string
   * - `DrbdOptions/auto-diskful-allow-cleanup` - boolean_true_false
   *
   *     Allows this resource to be cleaned up after toggle-disk + resync is finished
   */
  nodeModify: {
    parameters: {
      path: {
        /** node to use */
        node: string;
      };
    };
    responses: {
      /** node modified */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['NodeModify'];
      };
    };
  };
  /** Delete a node from Linstor */
  nodeDelete: {
    parameters: {
      path: {
        /** node to use */
        node: string;
      };
    };
    responses: {
      /** node deleted */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /** Delete an unrecoverable node */
  nodeLost: {
    parameters: {
      path: {
        /** node to use */
        node: string;
      };
    };
    responses: {
      /** node deleted */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /** Reconnect a node to the controller */
  nodeReconnect: {
    parameters: {
      path: {
        /** node to use */
        node: string;
      };
    };
    responses: {
      /** node put into reconnect cycle */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /** Returns the list of netinterfaces for this node */
  netinterfaceList: {
    parameters: {
      path: {
        /** node to use */
        node: string;
      };
      query: {
        /** number of records to skip for pagination */
        offset?: number;
        /** maximum number of records to return */
        limit?: number;
      };
    };
    responses: {
      /** Array of net-interfaces */
      200: {
        content: {
          'application/json': components['schemas']['NetInterface'][];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /**
   * Create a netinterface on a node
   *
   * If satellite_port and satellite_encryption_type are given
   * the netinterface can also work as connection to the controller
   */
  netinterfaceCreate: {
    parameters: {
      path: {
        /** node to use */
        node: string;
      };
    };
    responses: {
      /** netinterface created */
      201: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['NetInterface'];
      };
    };
  };
  /** Modify a netinterface from a node */
  netinterfaceModified: {
    parameters: {
      path: {
        /** node to use */
        node: string;
        /** netinterface name to use */
        netinterface: string;
      };
    };
    responses: {
      /** netinterface modified */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['NetInterface'];
      };
    };
  };
  /** Delete a netinterface from a node */
  netinterfaceDelete: {
    parameters: {
      path: {
        /** node to use */
        node: string;
        /** netinterface name to use */
        netinterface: string;
      };
    };
    responses: {
      /** netinterface deleted */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /** Lists all storage pools of a node */
  nodeStoragePoolList: {
    parameters: {
      path: {
        /** node to use */
        node: string;
      };
      query: {
        /** Filter only for the specified nodes, if not specified, no filtering. */
        nodes?: string[];
        /** Filter only for the specified storage pools, if not specified no filtering. */
        storage_pools?: string[];
        /** number of records to skip for pagination */
        offset?: number;
        /** maximum number of records to return */
        limit?: number;
        /** query data from cache if available */
        cached?: boolean;
      };
    };
    responses: {
      /** Array list of all storage pools */
      200: {
        content: {
          'application/json': components['schemas']['StoragePool'][];
        };
      };
    };
  };
  /**
   * Creates a new storage pool on this node.
   *
   * `provider_kind` has to be specified and additional to that
   * the linked `StorDriver` property that has the value to the backing pool:
   *
   *   * `LVM`: `StorDriver/LvmVg`
   *   * `LVM_THIN`: `StorDriver/LvmVg` and `StorDriver/ThinPool`
   *   * `ZFS`: `StorDriver/ZPool`
   *   * `ZFS_THIN`: `StorDriver/ZPoolThin`
   *   * `DISKLESS`: Does not need a property as it has no backing pool
   */
  nodeStoragePoolCreate: {
    parameters: {
      path: {
        /** node to use */
        node: string;
      };
    };
    responses: {
      /** storage pool created */
      201: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['StoragePool'];
      };
    };
  };
  /**
   * Sets or modifies properties
   *
   * Possible properties are:
   * - `StorDriver/StorPoolName` - regex[`[a-zA-Z0-9_/-]+`]
   * - `StorDriver/LvmVg` - regex[`[a-zA-Z0-9_-]+`]
   * - `StorDriver/ThinPool` - regex[`[a-zA-Z0-9_-]+`]
   * - `StorDriver/ZPool` - regex[`[a-zA-Z0-9_/-]+`]
   * - `StorDriver/ZPoolThin` - regex[`[a-zA-Z0-9_/-]+`]
   * - `StorDriver/FileDir` - regex[`.*`]
   * - `PrefNic` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Preferred network interface to use
   *
   * - `NVMe/PrefNic` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Preferred network interface to use
   *
   * - `StorDriver/LvcreateType` - enum
   *     * linear
   *     * striped
   *     * mirror
   *     * raid0
   *     * raid1
   *     * raid4
   *     * raid5
   *     * raid6
   *     * raid10
   *     * lzma
   *     * lz4
   *
   * - `StorDriver/LvcreateOptions` - regex[`.*`]
   *
   *     Additional parameters added to every 'lvcreate ... ' command
   *
   * - `StorDriver/ZfscreateOptions` - regex[`.*`]
   *
   *     Additional parameters added to every 'zfs create ... ' command
   *
   * - `StorDriver/WaitTimeoutAfterCreate` - regex[`[0-9]+`]
   * - `sys/fs/blkio_throttle_read` - long
   *
   *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device
   *
   * - `sys/fs/blkio_throttle_write` - long
   *
   *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device
   *
   * - `sys/fs/blkio_throttle_read_iops` - long
   *
   *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_iops_device
   *
   * - `sys/fs/blkio_throttle_write_iops` - long
   *
   *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_iops_device
   *
   * - `StorDriver/Openflex/ApiHost` - regex[`.+`]
   *
   *     Openflex API host name
   *
   * - `StorDriver/Openflex/ApiPort` - regex[`[0-9]+`]
   *
   *     Openflex API port
   *
   * - `StorDriver/Openflex/UserName` - regex[`.+`]
   *
   *     Openflex user name
   *
   * - `StorDriver/Openflex/UserPassword` - regex[`.+`]
   *
   *     Openflex password
   *
   * - `StorDriver/Openflex/StorDev` - regex[`.+`]
   *
   *     Openflex storage device
   *
   * - `StorDriver/Openflex/StorDevHost` - regex[`.+`]
   *
   *     Openflex storage device host
   *
   * - `StorDriver/Openflex/StorPool` - regex[`[0-9]+`]
   *
   *     Openflex storage pool name
   *
   * - `Autoplacer/MaxThroughput` - long
   *
   *     The maximum throughput the given storage pool is capable of.
   */
  nodeStoragePoolModify: {
    parameters: {
      path: {
        /** node to use */
        node: string;
        /** Storage pool to use */
        storagepool: string;
      };
      query: {
        /** number of records to skip for pagination */
        offset?: number;
        /** maximum number of records to return */
        limit?: number;
        /** query data from cache if available */
        cached?: boolean;
      };
    };
    responses: {
      /** storage pool modified */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['StoragePoolDefinitionModify'];
      };
    };
  };
  /** Delete a storage pool */
  nodeStoragePoolDelete: {
    parameters: {
      path: {
        /** node to use */
        node: string;
        /** Storage pool to use */
        storagepool: string;
      };
      query: {
        /** number of records to skip for pagination */
        offset?: number;
        /** maximum number of records to return */
        limit?: number;
        /** query data from cache if available */
        cached?: boolean;
      };
    };
    responses: {
      /** storage pool deleted */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
  };
  /** Show Satellite config */
  SatelliteConfig: {
    parameters: {
      path: {
        /** node to use */
        node: string;
      };
    };
    responses: {
      /** Satellite config */
      200: {
        content: {
          'application/json': components['schemas']['SatelliteConfig'];
        };
      };
      /** Access denied */
      401: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
      /** Node offline */
      503: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
  };
  StltSetConfig: {
    parameters: {
      path: {
        /** node to use */
        node: string;
      };
    };
    responses: {
      /** Response on whether the operation was successful */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** Access denied */
      401: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SatelliteConfig'];
      };
    };
  };
  /**
   * Evacuates DRBD resources from the given node to other available nodes
   * and deletes the evacuated resources once the sync is complete. Additionally
   * sets the Node into EVACUATE state (no new resources allowed)
   */
  nodeEvacuate: {
    parameters: {
      path: {
        /** node to use */
        node: string;
      };
    };
    responses: {
      /** resources started to evacaute */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /** Adds an EBS node to Linstor */
  nodeAddEbs: {
    responses: {
      /** node created */
      201: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    /** Node to add to Linstor */
    requestBody: {
      content: {
        'application/json': components['schemas']['NodeCreateEbs'];
      };
    };
  };
  /**
   * Lists all resource definitions.
   *
   * A single resource definition can be queried by adding its name
   * to the resource string like:
   *
   * /v1/resource-definitions/rsc1
   */
  resourceDefinitionList: {
    parameters: {
      query: {
        /** Filter only for the specified resource definitions, if not specified no filtering. */
        resource_definitions?: string[];
        /** filter by given properties, full property path */
        props?: string[];
        /** number of records to skip for pagination */
        offset?: number;
        /** maximum number of records to return */
        limit?: number;
      };
    };
    responses: {
      /** Array of all resource-definitions */
      200: {
        content: {
          'application/json': components['schemas']['ResourceDefinition'][];
        };
      };
    };
  };
  /**
   * Adds a resource-definition.
   *
   * Only required property is the name of the resource definition.
   * All other properties are optional.
   */
  resourceDefinitionCreate: {
    responses: {
      /** resource-definition created */
      201: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ResourceDefinitionCreate'];
      };
    };
  };
  /** Returns a resource definition stats object. */
  resourceDefinitionStats: {
    responses: {
      /** Object stats */
      200: {
        content: {
          'application/json': components['schemas']['ResourceDefinitionStats'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
  };
  /**
   * Sets or modifies properties
   *
   * Possible properties are:
   * - `StorPoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Linstor storage pool name to use.
   *
   * - `StorPoolNameDrbdMeta` - regex[`^|.internal|[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Linstor storage pool name to use for external metadata.
   *
   * - `PeerSlotsNewResource` - range[`1-31`]
   *
   *     DRBD peer slots to allocate for newly created resources (default 7), the number of peer slots cannot be changed once the resource is created, so allow sufficient slots to increase redundancy in the future
   *
   * - `DrbdProxy/CompressionType` - enum
   *     * zlib
   *     * lzma
   *     * lz4
   *     * zstd
   *
   * - `DrbdOptions/AutoEvictMinReplicaCount` - long
   *
   *     The minimum amount of replicas that should be present for a resource at all times.
   *
   * - `FileSystem/Type` - enum
   *
   *     File system type to use
   *
   *     * ext4
   *     * xfs
   *
   * - `FileSystem/MkfsParams` - string
   *
   *     Additional parameters for the mkfs command
   *
   * - `NVMe/TRType` - enum
   *
   *     NVMe transportion type
   *
   *     * rdma
   *     * tcp
   *
   * - `NVMe/Port` - range[`1-65535`]
   *
   *     NVMe port
   *
   * - `StorDriver/LvcreateType` - enum
   *     * linear
   *     * striped
   *     * mirror
   *     * raid0
   *     * raid1
   *     * raid4
   *     * raid5
   *     * raid6
   *     * raid10
   *     * lzma
   *     * lz4
   *
   * - `StorDriver/LvcreateOptions` - regex[`.*`]
   *
   *     Additional parameters added to every 'lvcreate ... ' command
   *
   * - `StorDriver/ZfscreateOptions` - regex[`.*`]
   *
   *     Additional parameters added to every 'zfs create ... ' command
   *
   * - `sys/fs/blkio_throttle_read` - long
   *
   *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device
   *
   * - `sys/fs/blkio_throttle_write` - long
   *
   *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device
   *
   * - `sys/fs/blkio_throttle_read_iops` - long
   *
   *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_iops_device
   *
   * - `sys/fs/blkio_throttle_write_iops` - long
   *
   *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_iops_device
   *
   * - `DrbdOptions/auto-quorum` - enum
   *
   *     Enables automatic setting of the 'quroum' and 'on-no-quroum' property
   *
   *     * io-error
   *     * suspend-io
   *     * disabled
   *
   * - `DrbdOptions/auto-add-quorum-tiebreaker` - boolean_true_false
   *
   *     Enables automatic management (creation and deletion) of tie breaking resource
   *
   * - `DrbdOptions/auto-diskful` - long
   *
   *     Makes a resource diskful if it was continously diskless primary for X minutes
   *
   * - `DrbdOptions/auto-diskful-allow-cleanup` - boolean_true_false
   *
   *     Allows this resource to be cleaned up after toggle-disk + resync is finished
   *
   * - `Writecache/PoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Linstor storage pool name for writecache
   *
   * - `Writecache/Size` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
   *
   *     Size of the writecache in % (0-100) or KiB otherwise
   *
   * - `Writecache/Options/StartSector` - long
   *
   *     offset from the start of cache device in 512-byte sectors
   *
   * - `Writecache/Options/HighWatermark` - long
   *
   *     start writeback when the number of used blocks reach this watermark
   *
   * - `Writecache/Options/LowWatermark` - long
   *
   *     stop writeback when the number of used blocks drops below this watermark
   *
   * - `Writecache/Options/WritebackJobs` - long
   *
   *     limit the number of blocks that are in flight during writeback. Setting this value reduces writeback throughput, but it may improve latency of read requests
   *
   * - `Writecache/Options/AutocommitBlocks` - long
   *
   *     when the application writes this amount of blocks without issuing the FLUSH request, the blocks are automatically commited
   *
   * - `Writecache/Options/AutocommitTime` - long
   *
   *     autocommit time in milliseconds. The data is automatically commited if this time passes and no FLUSH request is received
   *
   * - `Writecache/Options/Fua` - enum
   *
   *     "On" results in "fua" as argument, whereas the value "Off" results in "nofua" argument
   *
   *     * On
   *     * Off
   *
   * - `Writecache/Options/Additional` - string
   *
   *     Additional arguments passed through
   *
   * - `Cache/OpMode` - enum
   *
   *     Operation mode
   *
   *     * writeback
   *     * writethrough
   *     * passthrough
   *
   * - `Cache/MetaPool` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Name of the storage pool used for the cache metadata. If not specified, this will default to the CachePool property
   *
   * - `Cache/Metasize` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
   *
   *     Size of the cache in % (0-100) or KiB otherwise.
   *
   * - `Cache/CachePool` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Name of the storage pool used for the cache cache device
   *
   * - `Cache/Cachesize` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
   *
   *     Size of the cache in % (0-100) or KiB otherwise.
   *
   * - `Cache/Blocksize` - long
   *
   *     Block size
   *
   * - `Cache/Policy` - enum
   *
   *     Replacemant policy
   *
   *     * mq
   *     * smq
   *     * cleaner
   *
   * - `SnapshotShipping/SourceNode` - string
   *
   *     Node name of the snapshot shipping source
   *
   * - `SnapshotShipping/TargetNode` - string
   *
   *     Node name of the snapshot shipping target
   *
   * - `SnapshotShipping/RunEvery` - long
   *
   *     Runs every X minutes an auto-snapshot-shipping unless the current snapshot-shipping is still running. In this case a new one will be started asap.
   *
   * - `SnapshotShipping/Keep` - long
   *
   *     Keeps the last X sihpped snapshots. Removing this property or having a value <= 0 disables auto-cleanup, all auto-snapshots will be kept
   *
   * - `AutoSnapshot/RunEvery` - long
   *
   *     Runs every X minutes an snapshot-creation. Removing this property or having a value <= 0 disables auto-snapshotting.
   *
   * - `AutoSnapshot/Keep` - long
   *
   *     Keeps the last X auto-snapshots. Removing this property or having a value <= 0 disables auto-cleanup, all auto-snapshots will be kept
   *
   * - `AutoSnapshot/NextAutoId` - long
   *
   *     The next ID to try for auto-snapshots
   *
   * - `DrbdOptions/Disk/on-io-error` - enum
   *     * pass_on
   *     * call-local-io-error
   *     * detach
   *
   * - `DrbdOptions/Disk/disk-barrier` - boolean
   * - `DrbdOptions/Disk/disk-flushes` - boolean
   * - `DrbdOptions/Disk/disk-drain` - boolean
   * - `DrbdOptions/Disk/md-flushes` - boolean
   * - `DrbdOptions/Disk/resync-after` - string
   * - `DrbdOptions/Disk/al-extents` - range[`67-65534`]
   * - `DrbdOptions/Disk/al-updates` - boolean
   * - `DrbdOptions/Disk/discard-zeroes-if-aligned` - boolean
   * - `DrbdOptions/Disk/disable-write-same` - boolean
   * - `DrbdOptions/Disk/disk-timeout` - range[`0-6000`]
   * - `DrbdOptions/Disk/read-balancing` - enum
   *     * prefer-local
   *     * prefer-remote
   *     * round-robin
   *     * least-pending
   *     * when-congested-remote
   *     * 32K-striping
   *     * 64K-striping
   *     * 128K-striping
   *     * 256K-striping
   *     * 512K-striping
   *     * 1M-striping
   *
   * - `DrbdOptions/Disk/rs-discard-granularity` - range[`0-1048576`]
   * - `DrbdOptions/PeerDevice/resync-rate` - range[`1-8388608`]
   * - `DrbdOptions/PeerDevice/c-plan-ahead` - range[`0-300`]
   * - `DrbdOptions/PeerDevice/c-delay-target` - range[`1-100`]
   * - `DrbdOptions/PeerDevice/c-fill-target` - range[`0-1048576`]
   * - `DrbdOptions/PeerDevice/c-max-rate` - range[`250-4194304`]
   * - `DrbdOptions/PeerDevice/c-min-rate` - range[`0-4194304`]
   * - `DrbdOptions/PeerDevice/bitmap` - boolean
   * - `DrbdOptions/Resource/cpu-mask` - string
   * - `DrbdOptions/Resource/on-no-data-accessible` - enum
   *     * io-error
   *     * suspend-io
   *
   * - `DrbdOptions/Resource/auto-promote` - boolean
   * - `DrbdOptions/Resource/peer-ack-window` - range[`2048-204800`]
   * - `DrbdOptions/Resource/peer-ack-delay` - range[`1-10000`]
   * - `DrbdOptions/Resource/twopc-timeout` - range[`50-600`]
   * - `DrbdOptions/Resource/twopc-retry-timeout` - range[`1-50`]
   * - `DrbdOptions/Resource/auto-promote-timeout` - range[`0-600`]
   * - `DrbdOptions/Resource/max-io-depth` - range[`4-4294967295`]
   * - `DrbdOptions/Resource/quorum` - enum [`1-32`]
   *     * off
   *     * majority
   *     * all
   *
   * - `DrbdOptions/Resource/on-no-quorum` - enum
   *     * io-error
   *     * suspend-io
   *
   * - `DrbdOptions/Resource/quorum-minimum-redundancy` - enum [`1-32`]
   *     * off
   *     * majority
   *     * all
   *
   * - `DrbdOptions/Net/transport` - string
   * - `DrbdOptions/Net/protocol` - enum
   *     * A
   *     * B
   *     * C
   *
   * - `DrbdOptions/Net/timeout` - range[`1-600`]
   * - `DrbdOptions/Net/max-epoch-size` - range[`1-20000`]
   * - `DrbdOptions/Net/connect-int` - range[`1-120`]
   * - `DrbdOptions/Net/ping-int` - range[`1-120`]
   * - `DrbdOptions/Net/sndbuf-size` - range[`0-10485760`]
   * - `DrbdOptions/Net/rcvbuf-size` - range[`0-10485760`]
   * - `DrbdOptions/Net/ko-count` - range[`0-200`]
   * - `DrbdOptions/Net/allow-two-primaries` - boolean
   * - `DrbdOptions/Net/cram-hmac-alg` - string
   * - `DrbdOptions/Net/shared-secret` - string
   * - `DrbdOptions/Net/after-sb-0pri` - enum
   *     * disconnect
   *     * discard-younger-primary
   *     * discard-older-primary
   *     * discard-zero-changes
   *     * discard-least-changes
   *     * discard-local
   *     * discard-remote
   *
   * - `DrbdOptions/Net/after-sb-1pri` - enum
   *     * disconnect
   *     * consensus
   *     * discard-secondary
   *     * call-pri-lost-after-sb
   *     * violently-as0p
   *
   * - `DrbdOptions/Net/after-sb-2pri` - enum
   *     * disconnect
   *     * call-pri-lost-after-sb
   *     * violently-as0p
   *
   * - `DrbdOptions/Net/always-asbp` - boolean
   * - `DrbdOptions/Net/rr-conflict` - enum
   *     * disconnect
   *     * call-pri-lost
   *     * violently
   *     * retry-connect
   *
   * - `DrbdOptions/Net/ping-timeout` - range[`1-300`]
   * - `DrbdOptions/Net/data-integrity-alg` - string
   * - `DrbdOptions/Net/tcp-cork` - boolean
   * - `DrbdOptions/Net/on-congestion` - enum
   *     * block
   *     * pull-ahead
   *     * disconnect
   *
   * - `DrbdOptions/Net/congestion-fill` - range[`0-20971520`]
   * - `DrbdOptions/Net/congestion-extents` - range[`67-65534`]
   * - `DrbdOptions/Net/csums-alg` - string
   * - `DrbdOptions/Net/csums-after-crash-only` - boolean
   * - `DrbdOptions/Net/verify-alg` - string
   * - `DrbdOptions/Net/use-rle` - boolean
   * - `DrbdOptions/Net/socket-check-timeout` - range[`0-300`]
   * - `DrbdOptions/Net/fencing` - enum
   *     * dont-care
   *     * resource-only
   *     * resource-and-stonith
   *
   * - `DrbdOptions/Net/max-buffers` - range[`32-131072`]
   * - `DrbdOptions/Net/allow-remote-read` - boolean
   * - `DrbdOptions/Handlers/after-resync-target` - string
   * - `DrbdOptions/Handlers/before-resync-target` - string
   * - `DrbdOptions/Handlers/before-resync-source` - string
   * - `DrbdOptions/Handlers/out-of-sync` - string
   * - `DrbdOptions/Handlers/quorum-lost` - string
   * - `DrbdOptions/Handlers/fence-peer` - string
   * - `DrbdOptions/Handlers/unfence-peer` - string
   * - `DrbdOptions/Handlers/initial-split-brain` - string
   * - `DrbdOptions/Handlers/local-io-error` - string
   * - `DrbdOptions/Handlers/pri-lost` - string
   * - `DrbdOptions/Handlers/pri-lost-after-sb` - string
   * - `DrbdOptions/Handlers/pri-on-incon-degr` - string
   * - `DrbdOptions/Handlers/split-brain` - string
   */
  resourceDefinitionModify: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
      };
    };
    responses: {
      /** resource-definition modified */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ResourceDefinitionModify'];
      };
    };
  };
  /** Delete a resource-definition */
  resourceDefinitionDelete: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
      };
    };
    responses: {
      /** resource-definition deleted */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
  };
  /**
   * Clones the resource definition with all resources and volume with the current data and
   * the best/fastest possible clone method. Clone method depends on storage pool type:
   *   * LVM -> dd
   *   * LVM-thin -> snapshot -> logical volume
   *   * ZFS -> zfs send/recieve
   */
  resourceDefinitionClone: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
      };
    };
    responses: {
      /** resource defintion clone process started */
      201: {
        content: {
          'application/json': components['schemas']['ResourceDefinitionCloneStarted'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ResourceDefinitionCloneRequest'];
      };
    };
  };
  /** Get info of the current clone status. e.g. if completed. */
  resourceDefinitionCloneStatus: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** resource clone name */
        resourceClone: string;
      };
    };
    responses: {
      /** resource defintion clone status */
      200: {
        content: {
          'application/json': components['schemas']['ResourceDefinitionCloneStatus'];
        };
      };
      /** object not found */
      404: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /** Get info if the resource is synced on all nodes */
  resourceDefinitionSyncStatus: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
      };
    };
    responses: {
      /** resource defintion sync status */
      200: {
        content: {
          'application/json': components['schemas']['ResourceDefinitionSyncStatus'];
        };
      };
      /** object not found */
      404: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /**
   * Enables deployment of a previously created external file for a resource definition.
   * This has the effect that the external file will be created in a host's file
   * system whenever `resource` is deployed on that host.
   */
  resourceDeploy: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** Name of an external file. Must be an absolute path in URL-encoding */
        extFileName: string;
      };
    };
    responses: {
      /** deployment of the external file enabled */
      200: unknown;
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /**
   * Removes the requirement from this resource definition to create the given external file.
   * If nothing requires the external file to exist on a satellite, the satellite also will delete the
   * external file from the host's file system.
   */
  resourceUndeploy: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** Name of an external file. Must be an absolute path in URL-encoding */
        extFileName: string;
      };
    };
    responses: {
      /** deployment of external file disabled */
      200: unknown;
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /**
   * Lists all volume definitions.
   *
   * A single volume definition can be queried by adding its name
   * to the resource string like:
   *
   * /v1/resource-definitions/rsc1/volume-definitions/0
   */
  volumeDefinitionList: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
      };
      query: {
        /** number of records to skip for pagination */
        offset?: number;
        /** maximum number of records to return */
        limit?: number;
      };
    };
    responses: {
      /** Array of all volume-definitions */
      200: {
        content: {
          'application/json': components['schemas']['VolumeDefinition'][];
        };
      };
    };
  };
  /**
   * Adds a volume-definition.
   *
   * Required properties is only `size`, all other will be auto generated if not given.
   */
  volumeDefinitionCreate: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
      };
    };
    responses: {
      /** volume-definition created */
      201: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['VolumeDefinitionCreate'];
      };
    };
  };
  /**
   * Sets or modifies properties
   *
   * Possible properties are:
   * - `StorPoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Linstor storage pool name to use.
   *
   * - `StorPoolNameDrbdMeta` - regex[`^|.internal|[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Linstor storage pool name to use for external metadata.
   *
   * - `OverrideVlmId` - regex[`.*`]
   *
   *     Overwrites the generated '<resource-name>_<5 digit volume number>' volume name for migration purposes
   *
   * - `FileSystem/Type` - enum
   *
   *     File system type to use
   *
   *     * ext4
   *     * xfs
   *
   * - `FileSystem/MkfsParams` - string
   *
   *     Additional parameters for the mkfs command
   *
   * - `StorDriver/LvcreateType` - enum
   *     * linear
   *     * striped
   *     * mirror
   *     * raid0
   *     * raid1
   *     * raid4
   *     * raid5
   *     * raid6
   *     * raid10
   *     * lzma
   *     * lz4
   *
   * - `StorDriver/LvcreateOptions` - regex[`.*`]
   *
   *     Additional parameters added to every 'lvcreate ... ' command
   *
   * - `StorDriver/ZfscreateOptions` - regex[`.*`]
   *
   *     Additional parameters added to every 'zfs create ... ' command
   *
   * - `DrbdCurrentGi` - regex[`[a-fA-F0-9]{16}`]
   *
   *     Initial DRBD generation id, if initial sync is skipped, this ID will be set
   *
   * - `sys/fs/blkio_throttle_read` - long
   *
   *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device
   *
   * - `sys/fs/blkio_throttle_write` - long
   *
   *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device
   *
   * - `sys/fs/blkio_throttle_read_iops` - long
   *
   *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_iops_device
   *
   * - `sys/fs/blkio_throttle_write_iops` - long
   *
   *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_iops_device
   *
   * - `Writecache/PoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Linstor storage pool name for writecache
   *
   * - `Writecache/Size` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
   *
   *     Size of the writecache in % (0-100) or KiB otherwise
   *
   * - `Writecache/Options/StartSector` - long
   *
   *     offset from the start of cache device in 512-byte sectors
   *
   * - `Writecache/Options/HighWatermark` - long
   *
   *     start writeback when the number of used blocks reach this watermark
   *
   * - `Writecache/Options/LowWatermark` - long
   *
   *     stop writeback when the number of used blocks drops below this watermark
   *
   * - `Writecache/Options/WritebackJobs` - long
   *
   *     limit the number of blocks that are in flight during writeback. Setting this value reduces writeback throughput, but it may improve latency of read requests
   *
   * - `Writecache/Options/AutocommitBlocks` - long
   *
   *     when the application writes this amount of blocks without issuing the FLUSH request, the blocks are automatically commited
   *
   * - `Writecache/Options/AutocommitTime` - long
   *
   *     autocommit time in milliseconds. The data is automatically commited if this time passes and no FLUSH request is received
   *
   * - `Writecache/Options/Fua` - enum
   *
   *     "On" results in "fua" as argument, whereas the value "Off" results in "nofua" argument
   *
   *     * On
   *     * Off
   *
   * - `Writecache/Options/Additional` - string
   *
   *     Additional arguments passed through
   *
   * - `Cache/OpMode` - enum
   *
   *     Operation mode
   *
   *     * writeback
   *     * writethrough
   *     * passthrough
   *
   * - `Cache/MetaPool` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Name of the storage pool used for the cache metadata. If not specified, this will default to the CachePool property
   *
   * - `Cache/Metasize` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
   *
   *     Size of the cache in % (0-100) or KiB otherwise.
   *
   * - `Cache/CachePool` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Name of the storage pool used for the cache cache device
   *
   * - `Cache/Cachesize` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
   *
   *     Size of the cache in % (0-100) or KiB otherwise.
   *
   * - `Cache/Blocksize` - long
   *
   *     Block size
   *
   * - `Cache/Policy` - enum
   *
   *     Replacemant policy
   *
   *     * mq
   *     * smq
   *     * cleaner
   *
   * - `DrbdOptions/Disk/on-io-error` - enum
   *     * pass_on
   *     * call-local-io-error
   *     * detach
   *
   * - `DrbdOptions/Disk/disk-barrier` - boolean
   * - `DrbdOptions/Disk/disk-flushes` - boolean
   * - `DrbdOptions/Disk/disk-drain` - boolean
   * - `DrbdOptions/Disk/md-flushes` - boolean
   * - `DrbdOptions/Disk/resync-after` - string
   * - `DrbdOptions/Disk/al-extents` - range[`67-65534`]
   * - `DrbdOptions/Disk/al-updates` - boolean
   * - `DrbdOptions/Disk/discard-zeroes-if-aligned` - boolean
   * - `DrbdOptions/Disk/disable-write-same` - boolean
   * - `DrbdOptions/Disk/disk-timeout` - range[`0-6000`]
   * - `DrbdOptions/Disk/read-balancing` - enum
   *     * prefer-local
   *     * prefer-remote
   *     * round-robin
   *     * least-pending
   *     * when-congested-remote
   *     * 32K-striping
   *     * 64K-striping
   *     * 128K-striping
   *     * 256K-striping
   *     * 512K-striping
   *     * 1M-striping
   *
   * - `DrbdOptions/Disk/rs-discard-granularity` - range[`0-1048576`]
   */
  volumeDefinitionModify: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** Volume number of the definition */
        volume_number: number;
      };
    };
    responses: {
      /** volume-definition modified */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['VolumeDefinitionModify'];
      };
    };
  };
  /** Delete a volume-definition */
  volumeDefinitionDelete: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** Volume number of the definition */
        volume_number: number;
      };
    };
    responses: {
      /** volume-definition deleted */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
  };
  /**
   * Lists all resources for a resource-definition.
   *
   * A single resource can be queried by adding its name
   * to the resource string like:
   *
   * /v1/resource-definitions/rsc1/resources/nodeA
   */
  resourceList: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
      };
      query: {
        /** number of records to skip for pagination */
        offset?: number;
        /** maximum number of records to return */
        limit?: number;
      };
    };
    responses: {
      /** Array of all resources for the resource-definition */
      200: {
        content: {
          'application/json': components['schemas']['Resource'][];
        };
      };
    };
  };
  /** Adds one or more resource(s). */
  resourceCreate: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
      };
    };
    responses: {
      /** resource created */
      201: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ResourceCreate'][];
      };
    };
  };
  /**
   * Sets or modifies properties
   *
   * Possible properties are:
   * - `StorPoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Linstor storage pool name to use.
   *
   * - `StorPoolNameDrbdMeta` - regex[`^|.internal|[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Linstor storage pool name to use for external metadata.
   *
   * - `PrefNic` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Preferred network interface to use
   *
   * - `PeerSlots` - range[`1-31`]
   *
   *     DRBD peer slots present on resource
   *
   * - `FileSystem/Type` - enum
   *
   *     File system type to use
   *
   *     * ext4
   *     * xfs
   *
   * - `FileSystem/MkfsParams` - string
   *
   *     Additional parameters for the mkfs command
   *
   * - `NVMe/PrefNic` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Preferred network interface to use
   *
   * - `sys/fs/blkio_throttle_read` - long
   *
   *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device
   *
   * - `sys/fs/blkio_throttle_write` - long
   *
   *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device
   *
   * - `sys/fs/blkio_throttle_read_iops` - long
   *
   *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_iops_device
   *
   * - `sys/fs/blkio_throttle_write_iops` - long
   *
   *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_iops_device
   *
   * - `DrbdOptions/auto-diskful-allow-cleanup` - boolean_true_false
   *
   *     Allows this resource to be cleaned up after toggle-disk + resync is finished
   */
  resourceModify: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** node to use */
        node: string;
      };
    };
    responses: {
      /** resource modified */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ResourceModify'];
      };
    };
  };
  /**
   * Adds a resource on a node.
   *
   * To use a specific storage pool add the `StorPoolName` property
   * and use the storage pool name as value.
   * If the `StorPoolName` property is not set, the `DfltStorPool` will be used.
   *
   * To create a diskless resource you have to set the "DISKLESS" flag in the flags list.
   * ```
   * {
   *   "resource": {
   *     "flags": ["DISKLESS"]
   *   }
   * }
   * ```
   */
  resourceCreateOnNode: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** node to use */
        node: string;
      };
    };
    responses: {
      /** resource created */
      201: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ResourceCreate'];
      };
    };
  };
  /** Delete a resource on a node */
  resourceDelete: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** node to use */
        node: string;
      };
    };
    responses: {
      /** resource deleted */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
  };
  /**
   * Adds a resource on a node if not already deployed.
   *
   * New resources will be diskless, if possible. To force creation of
   * a diskful resource, set `diskful` to `true` in the request body.
   *
   * Optionally, you can override the layer stack for the created resource.
   * If not given, the default configuration for the resource definition is
   * used.
   *
   * The storage pool will be selected by the autoplacer.
   */
  resourceMakeAvailableOnNode: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** node to use */
        node: string;
      };
    };
    responses: {
      /** resource is either created or ensured to be available */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ResourceMakeAvailable'];
      };
    };
  };
  /** Activates the given resource if possible */
  ActivateRsc: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** node to use */
        node: string;
      };
    };
    responses: {
      /** Resource is now active */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /** Deactivates the given resource if possible */
  DeactivateRsc: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** node to use */
        node: string;
      };
    };
    responses: {
      /** Resource is now inctive */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /**
   * Lists all volumes for a resource-definition.
   *
   * A single volume can be queried by adding its volume number
   * to the resource string like:
   *
   * /v1/resource-definitions/rsc1/resources/nodeA/volumes/0
   */
  resourceVolumeList: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** node to use */
        node: string;
      };
      query: {
        /** number of records to skip for pagination */
        offset?: number;
        /** maximum number of records to return */
        limit?: number;
      };
    };
    responses: {
      /** Array of all volume for the resource */
      200: {
        content: {
          'application/json': components['schemas']['Volume'][];
        };
      };
    };
  };
  /**
   * Sets or modifies properties
   *
   * Possible properties are:
   * - `sys/fs/blkio_throttle_read` - number
   * - `sys/fs/blkio_throttle_write` - number
   */
  volumeModify: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** node to use */
        node: string;
        /** Volume number of the definition */
        volume_number: number;
      };
    };
    responses: {
      /** volume modified */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['VolumeModify'];
      };
    };
  };
  /** toggle a resource to a diskless resource */
  resourceToggleDiskless: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** node to use */
        node: string;
      };
    };
    responses: {
      /** resource toggled to diskless */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /** toggle a resource to a diskless. */
  resourceToggleDisklessDisklesspool: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** node to use */
        node: string;
        /** diskless pool to use. */
        disklesspool: string;
      };
    };
    responses: {
      /** resource toggled to diskless resource */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /** toggle a resource to a diskful resource using the default storage pool */
  resourceToggleDiskful: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** node to use */
        node: string;
      };
    };
    responses: {
      /** resource toggled to diskful */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ToggleDiskDiskful'];
      };
    };
  };
  /** toggle a resource to a diskful resource */
  resourceToggleDiskfulStoragepool: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** node to use */
        node: string;
        /** Storage pool to use */
        storagepool: string;
      };
    };
    responses: {
      /** resource toggled to diskful */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ToggleDiskDiskful'];
      };
    };
  };
  /** migrate a resource to another node without reducing the redundancy count */
  resourceMigrateDisk: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** node to use */
        node: string;
        /** node that should be deleted after the successful migrate */
        fromnode: string;
      };
    };
    responses: {
      /** resource migrated to another node */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ToggleDiskDiskful'];
      };
    };
  };
  /** migrate a resource to another node without reducing the redundency count */
  resourceMigrateDiskStoragepool: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** node to use */
        node: string;
        /** node that should be deleted after the successful migrate */
        fromnode: string;
        /** Storage pool to use */
        storagepool: string;
      };
    };
    responses: {
      /** resource migrated to another node */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /**
   * Auto place the resource on the specified place_count redundency.
   * If place_count isn't given 2 is the default.
   */
  resourceAutoplace: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
      };
    };
    responses: {
      /** resource created */
      201: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AutoPlaceRequest'];
      };
    };
  };
  /** List all resource connections for resource */
  resourceConnectionsList: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
      };
    };
    responses: {
      /** list of resource connections */
      200: {
        content: {
          'application/json': components['schemas']['ResourceConnection'][];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /** show the specified resource connection */
  resourceConnectionList: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** source node of the connection */
        node_a: string;
        /** target node of the connection */
        node_b: string;
      };
    };
    responses: {
      /** list of resource connections */
      200: {
        content: {
          'application/json': components['schemas']['ResourceConnection'][];
        };
      };
      /** object not found */
      404: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /**
   * Sets or modifies properties
   *
   * Possible properties are:
   * - `DrbdOptions/PeerDevice/resync-rate` - range[`1-8388608`]
   * - `DrbdOptions/PeerDevice/c-plan-ahead` - range[`0-300`]
   * - `DrbdOptions/PeerDevice/c-delay-target` - range[`1-100`]
   * - `DrbdOptions/PeerDevice/c-fill-target` - range[`0-1048576`]
   * - `DrbdOptions/PeerDevice/c-max-rate` - range[`250-4194304`]
   * - `DrbdOptions/PeerDevice/c-min-rate` - range[`0-4194304`]
   * - `DrbdOptions/PeerDevice/bitmap` - boolean
   * - `DrbdOptions/Net/transport` - string
   * - `DrbdOptions/Net/protocol` - enum
   *     * A
   *     * B
   *     * C
   *
   * - `DrbdOptions/Net/timeout` - range[`1-600`]
   * - `DrbdOptions/Net/max-epoch-size` - range[`1-20000`]
   * - `DrbdOptions/Net/connect-int` - range[`1-120`]
   * - `DrbdOptions/Net/ping-int` - range[`1-120`]
   * - `DrbdOptions/Net/sndbuf-size` - range[`0-10485760`]
   * - `DrbdOptions/Net/rcvbuf-size` - range[`0-10485760`]
   * - `DrbdOptions/Net/ko-count` - range[`0-200`]
   * - `DrbdOptions/Net/allow-two-primaries` - boolean
   * - `DrbdOptions/Net/cram-hmac-alg` - string
   * - `DrbdOptions/Net/shared-secret` - string
   * - `DrbdOptions/Net/after-sb-0pri` - enum
   *     * disconnect
   *     * discard-younger-primary
   *     * discard-older-primary
   *     * discard-zero-changes
   *     * discard-least-changes
   *     * discard-local
   *     * discard-remote
   *
   * - `DrbdOptions/Net/after-sb-1pri` - enum
   *     * disconnect
   *     * consensus
   *     * discard-secondary
   *     * call-pri-lost-after-sb
   *     * violently-as0p
   *
   * - `DrbdOptions/Net/after-sb-2pri` - enum
   *     * disconnect
   *     * call-pri-lost-after-sb
   *     * violently-as0p
   *
   * - `DrbdOptions/Net/always-asbp` - boolean
   * - `DrbdOptions/Net/rr-conflict` - enum
   *     * disconnect
   *     * call-pri-lost
   *     * violently
   *     * retry-connect
   *
   * - `DrbdOptions/Net/ping-timeout` - range[`1-300`]
   * - `DrbdOptions/Net/data-integrity-alg` - string
   * - `DrbdOptions/Net/tcp-cork` - boolean
   * - `DrbdOptions/Net/on-congestion` - enum
   *     * block
   *     * pull-ahead
   *     * disconnect
   *
   * - `DrbdOptions/Net/congestion-fill` - range[`0-20971520`]
   * - `DrbdOptions/Net/congestion-extents` - range[`67-65534`]
   * - `DrbdOptions/Net/csums-alg` - string
   * - `DrbdOptions/Net/csums-after-crash-only` - boolean
   * - `DrbdOptions/Net/verify-alg` - string
   * - `DrbdOptions/Net/use-rle` - boolean
   * - `DrbdOptions/Net/socket-check-timeout` - range[`0-300`]
   * - `DrbdOptions/Net/fencing` - enum
   *     * dont-care
   *     * resource-only
   *     * resource-and-stonith
   *
   * - `DrbdOptions/Net/max-buffers` - range[`32-131072`]
   * - `DrbdOptions/Net/allow-remote-read` - boolean
   */
  resourceConnectionModify: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** source node of the connection */
        node_a: string;
        /** target node of the connection */
        node_b: string;
      };
    };
    responses: {
      /** resource connection modified */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** object not found */
      404: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ResourceConnectionModify'];
      };
    };
  };
  /** List snapshots for a resource */
  resourceSnapshotsList: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
      };
    };
    responses: {
      /** Snapshots for the resource */
      200: {
        content: {
          'application/json': components['schemas']['Snapshot'][];
        };
      };
    };
  };
  /** Create a snapshot for a resource */
  resourceSnapshotCreate: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
      };
    };
    responses: {
      /** Snapshot created */
      201: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['Snapshot'];
      };
    };
  };
  /** List the given snapshot for a resource */
  resourceSnapshotList: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** Snapshot name to use */
        snapshot: string;
      };
    };
    responses: {
      /** Snapshot for the resource */
      200: {
        content: {
          'application/json': components['schemas']['Snapshot'];
        };
      };
    };
  };
  /** Delete a snapshot */
  resourceSnapshotDelete: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** Snapshot name to use */
        snapshot: string;
      };
      query: {
        /** Only delete snapshots of the given nodes. */
        nodes?: string[];
      };
    };
    responses: {
      /** Snapshot deleted */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /** Restore a snapshot to a new resource */
  resourceSnapshotRestore: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** Snapshot name to use */
        snapshot: string;
      };
    };
    responses: {
      /** Snapshot restored */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SnapshotRestore'];
      };
    };
  };
  /** Restore a snapshot volume definition to a new resource */
  resourceSnapshotsRestoreVolumeDefinition: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** Snapshot name to use */
        snapshot: string;
      };
    };
    responses: {
      /** Snapshot restored */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SnapshotRestore'];
      };
    };
  };
  /** Rollback a resource to the snapshot state */
  resourceSnapshotRollback: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** Snapshot name to use */
        snapshot: string;
      };
    };
    responses: {
      /** Snapshot rollbacked */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /** Transfers the resource from one node to another based on snapshot-shipping */
  snapshotShipping: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
      };
    };
    responses: {
      /** Snapshot shipping in progress */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SnapshotShipping'];
      };
    };
  };
  /**
   * Lists all resource groups.
   *
   * A single resource group can be queried by adding its name
   * to the resource string like:
   *
   * /v1/resource-groups/rscgrp1
   */
  resourceGroupList: {
    parameters: {
      query: {
        /** Filter only for the specified resource groups, if not specified no filtering. */
        resource_groups?: string[];
        /** filter by given properties, full property path */
        props?: string[];
        /** number of records to skip for pagination */
        offset?: number;
        /** maximum number of records to return */
        limit?: number;
      };
    };
    responses: {
      /** Array of all resource-groups */
      200: {
        content: {
          'application/json': components['schemas']['ResourceGroup'][];
        };
      };
    };
  };
  /**
   * Adds a resource-group.
   *
   * Only required property is the name of the resource group.
   * All other properties are optional.
   */
  resourceGroupCreate: {
    responses: {
      /** resource-group created */
      201: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ResourceGroup'];
      };
    };
  };
  /** Returns a resource group stats object. */
  resourceGroupStats: {
    responses: {
      /** Object stats */
      200: {
        content: {
          'application/json': components['schemas']['ResourceGroupStats'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
  };
  /**
   * Sets or modifies properties
   *
   * Possible properties are:
   * - `StorPoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Linstor storage pool name to use.
   *
   * - `PeerSlotsNewResource` - range[`1-31`]
   *
   *     DRBD peer slots to allocate for newly created resources (default 7), the number of peer slots cannot be changed once the resource is created, so allow sufficient slots to increase redundancy in the future
   *
   * - `DrbdProxy/CompressionType` - enum
   *     * zlib
   *     * lzma
   *     * lz4
   *
   * - `FileSystem/Type` - enum
   *
   *     File system type to use
   *
   *     * ext4
   *     * xfs
   *
   * - `FileSystem/MkfsParams` - string
   *
   *     Additional parameters for the mkfs command
   *
   * - `NVMe/enabled` - enum
   *     * rdma
   *     * tcp
   *
   * - `NVMe/enabled` - range[`1-65535`]
   * - `DrbdOptions/Disk/read-balancing` - enum
   *     * prefer-local
   *     * prefer-remote
   *     * round-robin
   *     * least-pending
   *     * when-congested-remote
   *     * 32K-striping
   *     * 64K-striping
   *     * 128K-striping
   *     * 256K-striping
   *     * 512K-striping
   *     * 1M-striping
   *
   * - `DrbdOptions/Disk/on-io-error` - enum
   *     * pass_on
   *     * call-local-io-error
   *     * detach
   *
   * - `DrbdOptions/Disk/disk-drain` - boolean
   * - `DrbdOptions/Disk/resync-after` - string
   * - `DrbdOptions/Disk/disk-timeout` - range[`0-6000`]
   * - `DrbdOptions/Disk/disable-write-same` - boolean
   * - `DrbdOptions/Disk/rs-discard-granularity` - range[`0-1048576`]
   * - `DrbdOptions/Disk/disk-flushes` - boolean
   * - `DrbdOptions/Disk/al-extents` - range[`67-65534`]
   * - `DrbdOptions/Disk/al-updates` - boolean
   * - `DrbdOptions/Disk/md-flushes` - boolean
   * - `DrbdOptions/Disk/disk-barrier` - boolean
   * - `DrbdOptions/Disk/discard-zeroes-if-aligned` - boolean
   * - `DrbdOptions/PeerDevice/c-fill-target` - range[`0-1048576`]
   * - `DrbdOptions/PeerDevice/c-max-rate` - range[`250-4194304`]
   * - `DrbdOptions/PeerDevice/resync-rate` - range[`1-8388608`]
   * - `DrbdOptions/PeerDevice/c-delay-target` - range[`1-100`]
   * - `DrbdOptions/PeerDevice/c-min-rate` - range[`0-4194304`]
   * - `DrbdOptions/PeerDevice/bitmap` - boolean
   * - `DrbdOptions/PeerDevice/c-plan-ahead` - range[`0-300`]
   * - `DrbdOptions/Resource/peer-ack-delay` - range[`1-10000`]
   * - `DrbdOptions/Resource/quorum-minimum-redundancy` - enum [`1-32`]
   *     * off
   *     * majority
   *     * all
   *
   * - `DrbdOptions/Resource/max-io-depth` - range[`4-4294967295`]
   * - `DrbdOptions/Resource/auto-promote-timeout` - range[`0-600`]
   * - `DrbdOptions/Resource/quorum` - enum [`1-32`]
   *     * off
   *     * majority
   *     * all
   *
   * - `DrbdOptions/Resource/on-no-data-accessible` - enum
   *     * io-error
   *     * suspend-io
   *
   * - `DrbdOptions/Resource/auto-promote` - boolean
   * - `DrbdOptions/Resource/cpu-mask` - string
   * - `DrbdOptions/Resource/twopc-timeout` - range[`50-600`]
   * - `DrbdOptions/Resource/twopc-retry-timeout` - range[`1-50`]
   * - `DrbdOptions/Resource/peer-ack-window` - range[`2048-204800`]
   * - `DrbdOptions/Resource/on-no-quorum` - enum
   *     * io-error
   *     * suspend-io
   *
   * - `DrbdOptions/Net/max-epoch-size` - range[`1-20000`]
   * - `DrbdOptions/Net/protocol` - enum
   *     * A
   *     * B
   *     * C
   *
   * - `DrbdOptions/Net/allow-two-primaries` - boolean
   * - `DrbdOptions/Net/after-sb-0pri` - enum
   *     * disconnect
   *     * discard-younger-primary
   *     * discard-older-primary
   *     * discard-zero-changes
   *     * discard-least-changes
   *     * discard-local
   *     * discard-remote
   *
   * - `DrbdOptions/Net/ko-count` - range[`0-200`]
   * - `DrbdOptions/Net/data-integrity-alg` - string
   * - `DrbdOptions/Net/ping-timeout` - range[`1-300`]
   * - `DrbdOptions/Net/sndbuf-size` - range[`0-10485760`]
   * - `DrbdOptions/Net/transport` - string
   * - `DrbdOptions/Net/rcvbuf-size` - range[`0-10485760`]
   * - `DrbdOptions/Net/max-buffers` - range[`32-131072`]
   * - `DrbdOptions/Net/fencing` - enum
   *     * dont-care
   *     * resource-only
   *     * resource-and-stonith
   *
   * - `DrbdOptions/Net/csums-alg` - string
   * - `DrbdOptions/Net/always-asbp` - boolean
   * - `DrbdOptions/Net/congestion-extents` - range[`67-65534`]
   * - `DrbdOptions/Net/on-congestion` - enum
   *     * block
   *     * pull-ahead
   *     * disconnect
   *
   * - `DrbdOptions/Net/ping-int` - range[`1-120`]
   * - `DrbdOptions/Net/rr-conflict` - enum
   *     * disconnect
   *     * call-pri-lost
   *     * violently
   *
   * - `DrbdOptions/Net/tcp-cork` - boolean
   * - `DrbdOptions/Net/use-rle` - boolean
   * - `DrbdOptions/Net/csums-after-crash-only` - boolean
   * - `DrbdOptions/Net/socket-check-timeout` - range[`0-300`]
   * - `DrbdOptions/Net/congestion-fill` - range[`0-20971520`]
   * - `DrbdOptions/Net/cram-hmac-alg` - string
   * - `DrbdOptions/Net/verify-alg` - string
   * - `DrbdOptions/Net/shared-secret` - string
   * - `DrbdOptions/Net/connect-int` - range[`1-120`]
   * - `DrbdOptions/Net/timeout` - range[`1-600`]
   * - `DrbdOptions/Net/after-sb-2pri` - enum
   *     * disconnect
   *     * call-pri-lost-after-sb
   *     * violently-as0p
   *
   * - `DrbdOptions/Net/after-sb-1pri` - enum
   *     * disconnect
   *     * consensus
   *     * discard-secondary
   *     * call-pri-lost-after-sb
   *     * violently-as0p
   *
   * - `DrbdOptions/Handlers/after-resync-target` - string
   * - `DrbdOptions/Handlers/before-resync-target` - string
   * - `DrbdOptions/Handlers/before-resync-source` - string
   * - `DrbdOptions/Handlers/out-of-sync` - string
   * - `DrbdOptions/Handlers/quorum-lost` - string
   * - `DrbdOptions/Handlers/fence-peer` - string
   * - `DrbdOptions/Handlers/unfence-peer` - string
   * - `DrbdOptions/Handlers/initial-split-brain` - string
   * - `DrbdOptions/Handlers/local-io-error` - string
   * - `DrbdOptions/Handlers/pri-lost` - string
   * - `DrbdOptions/Handlers/pri-lost-after-sb` - string
   * - `DrbdOptions/Handlers/pri-on-incon-degr` - string
   * - `DrbdOptions/Handlers/split-brain` - string
   */
  resourceGroupModify: {
    parameters: {
      path: {
        /** resource group to use */
        resource_group: string;
      };
    };
    responses: {
      /** resource-group modified */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ResourceGroupModify'];
      };
    };
  };
  /** Delete a resource-group */
  resourceGroupDelete: {
    parameters: {
      path: {
        /** resource group to use */
        resource_group: string;
      };
    };
    responses: {
      /** resource-group deleted */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
  };
  /** Creates a new resource-definition and auto-deploys if configured to do so. */
  resourceGroupSpawn: {
    parameters: {
      path: {
        /** resource group to use */
        resource_group: string;
      };
    };
    responses: {
      /** resource-definition created and auto-deployed if configured accordingly */
      201: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ResourceGroupSpawn'];
      };
    };
  };
  /**
   * Lists all volume groups.
   *
   * A single volume group can be queried by adding its name
   * to the resource string like:
   *
   * /v1/resource-groups/rscgrp1/volume-groups/0
   */
  volumeGroupList: {
    parameters: {
      path: {
        /** resource group to use */
        resource_group: string;
      };
      query: {
        /** number of records to skip for pagination */
        offset?: number;
        /** maximum number of records to return */
        limit?: number;
      };
    };
    responses: {
      /** Array of all volume-groups */
      200: {
        content: {
          'application/json': components['schemas']['VolumeGroup'][];
        };
      };
    };
  };
  /** Adds a volume-group. */
  volumeGroupCreate: {
    parameters: {
      path: {
        /** resource group to use */
        resource_group: string;
      };
    };
    responses: {
      /** volume-group created */
      201: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['VolumeGroup'];
      };
    };
  };
  /**
   * Sets or modifies properties
   *
   * Possible properties are:
   * - `StorPoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Linstor storage pool name to use.
   *
   * - `OverrideVlmId` - regex[`.*`]
   *
   *     Overwrites the generated '<resource-name>_<5 digit volume number>' volume name for migration purposes
   *
   * - `AllowLargerVolumeSize` - boolean_true_false
   *
   *     Do not fail when the underlying volume is larger than expected
   *
   * - `FileSystem/Type` - enum
   *
   *     File system type to use
   *
   *     * ext4
   *     * xfs
   *
   * - `FileSystem/MkfsParams` - string
   *
   *     Additional parameters for the mkfs command
   *
   * - `StorDriver/LvcreateType` - enum
   *     * linear
   *     * striped
   *     * mirror
   *     * raid0
   *     * raid1
   *     * raid4
   *     * raid5
   *     * raid6
   *     * raid10
   *     * lzma
   *     * lz4
   *
   * - `DrbdCurrentGi` - regex[`[a-fA-F0-9]{16}`]
   * - `DrbdOptions/Disk/read-balancing` - enum
   *     * prefer-local
   *     * prefer-remote
   *     * round-robin
   *     * least-pending
   *     * when-congested-remote
   *     * 32K-striping
   *     * 64K-striping
   *     * 128K-striping
   *     * 256K-striping
   *     * 512K-striping
   *     * 1M-striping
   *
   * - `DrbdOptions/Disk/on-io-error` - enum
   *     * pass_on
   *     * call-local-io-error
   *     * detach
   *
   * - `DrbdOptions/Disk/disk-drain` - boolean
   * - `DrbdOptions/Disk/resync-after` - string
   * - `DrbdOptions/Disk/disk-timeout` - range[`0-6000`]
   * - `DrbdOptions/Disk/disable-write-same` - boolean
   * - `DrbdOptions/Disk/rs-discard-granularity` - range[`0-1048576`]
   * - `DrbdOptions/Disk/disk-flushes` - boolean
   * - `DrbdOptions/Disk/al-extents` - range[`67-65534`]
   * - `DrbdOptions/Disk/al-updates` - boolean
   * - `DrbdOptions/Disk/md-flushes` - boolean
   * - `DrbdOptions/Disk/disk-barrier` - boolean
   * - `DrbdOptions/Disk/discard-zeroes-if-aligned` - boolean
   */
  volumeGroupModify: {
    parameters: {
      path: {
        /** resource group to use */
        resource_group: string;
        /** Volume number of the definition */
        volume_number: number;
      };
    };
    responses: {
      /** volume-group modified */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['VolumeGroupModify'];
      };
    };
  };
  /** Delete a volume-group */
  volumeGroupDelete: {
    parameters: {
      path: {
        /** resource group to use */
        resource_group: string;
        /** Volume number of the definition */
        volume_number: number;
      };
    };
    responses: {
      /** volume-group deleted */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
  };
  /** Query the maximum possible volume size storage pools */
  queryMaxVolumeSizeFromRscGrp: {
    parameters: {
      path: {
        /** resource group to use */
        resource_group: string;
      };
    };
    responses: {
      /** list of usable storage pools */
      200: {
        content: {
          'application/json': components['schemas']['MaxVolumeSizes'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /** Adjusts (calls autoplace for) all resource-definitions of the given resource-group */
  resourceGroupAdjust: {
    parameters: {
      path: {
        /** resource group to use */
        resource_group: string;
      };
    };
    responses: {
      /** resource-definitions adjusted as configured. Might have created new resources. */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ResourceGroupAdjust'];
      };
    };
  };
  /** Adjusts (calls autoplace for) all resource-definitions of all resource-groups */
  resourceGroupAdjustAll: {
    responses: {
      /** resource-definitions adjusted as configured. Might have created new resources. */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ResourceGroupAdjust'];
      };
    };
  };
  /** Lists all controller properties. */
  controllerPropertyList: {
    responses: {
      /** A string to string map with all properties */
      200: {
        content: {
          'application/json': components['schemas']['Properties'];
        };
      };
    };
  };
  /**
   * Sets or modifies properties
   *
   * Possible properties are:
   * - `TcpPortAutoRange` - regex[`[0-9]+-[0-9]+`]
   *
   *     Range for auto-allocation of resource TCP ports
   *
   * - `MinorNrAutoRange` - regex[`[0-9]+-[0-9]+`]
   *
   *     Range for auto-allocation of volume minor numbers
   *
   * - `PeerSlotsNewResource` - range[`1-31`]
   *
   *     DRBD peer slots to allocate for newly created resources (default 7), the number of peer slots cannot be changed once the resource is created, so allow sufficient slots to increase redundancy in the future
   *
   * - `StorDriver/DMStats` - boolean_true_false
   *
   *     Enable dmstats on lvm create
   *
   * - `REST/disable-http-metrics` - boolean_true_false
   *
   *     Disable Prometheus /metrics on HTTP, if HTTPS is enabled
   *
   * - `DrbdOptions/AutoEvictAfterTime` - long
   *
   *     Time a node can be offline before it is declared EVICTED in minutes
   *
   * - `DrbdOptions/AutoEvictMaxDisconnectedNodes` - range[`0-100`]
   *
   *     Percentage(0-100) of nodes that can disconnect at the same time without the controller stopping the max_offline_time timer
   *
   * - `DrbdOptions/AutoEvictMinReplicaCount` - long
   *
   *     The minimum amount of replicas that should be present for a resource at all times.
   *
   * - `DrbdOptions/AutoEvictAllowEviction` - boolean_true_false
   *
   *     If set to true on a node, it cannot be evicted anymore
   *
   * - `NVMe/TRType` - enum
   *
   *     NVMe transportion type
   *
   *     * rdma
   *     * tcp
   *
   * - `NVMe/Port` - range[`1-65535`]
   *
   *     NVMe port
   *
   * - `NVMe/PrefNic` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Preferred network interface to use
   *
   * - `StorDriver/WaitTimeoutAfterCreate` - regex[`[0-9]+`]
   * - `sys/fs/blkio_throttle_read` - long
   *
   *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device
   *
   * - `sys/fs/blkio_throttle_write` - long
   *
   *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device
   *
   * - `sys/fs/blkio_throttle_read_iops` - long
   *
   *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_iops_device
   *
   * - `sys/fs/blkio_throttle_write_iops` - long
   *
   *     Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_iops_device
   *
   * - `SearchDomain` - string
   *
   *     Search domain node names, if no FQDN is given.
   *
   * - `ExtCmdWaitTimeout` - long
   *
   *     Wait timeout for an external command in milliseconds
   *
   * - `DrbdOptions/auto-quorum` - enum
   *
   *     Enables automatic setting of the 'quroum' and 'on-no-quroum' property
   *
   *     * io-error
   *     * suspend-io
   *     * disabled
   *
   * - `DrbdOptions/auto-add-quorum-tiebreaker` - boolean_true_false
   *
   *     Enables automatic management (creation and deletion) of tie breaking resource
   *
   * - `DrbdOptions/auto-diskful` - long
   *
   *     Makes a resource diskful if it was continously diskless primary for X minutes
   *
   * - `DrbdOptions/auto-diskful-allow-cleanup` - boolean_true_false
   *
   *     Allows this resource to be cleaned up after toggle-disk + resync is finished
   *
   * - `Writecache/PoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Linstor storage pool name for writecache
   *
   * - `Writecache/Size` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
   *
   *     Size of the writecache in % (0-100) or KiB otherwise
   *
   * - `Writecache/Options/StartSector` - long
   *
   *     offset from the start of cache device in 512-byte sectors
   *
   * - `Writecache/Options/HighWatermark` - long
   *
   *     start writeback when the number of used blocks reach this watermark
   *
   * - `Writecache/Options/LowWatermark` - long
   *
   *     stop writeback when the number of used blocks drops below this watermark
   *
   * - `Writecache/Options/WritebackJobs` - long
   *
   *     limit the number of blocks that are in flight during writeback. Setting this value reduces writeback throughput, but it may improve latency of read requests
   *
   * - `Writecache/Options/AutocommitBlocks` - long
   *
   *     when the application writes this amount of blocks without issuing the FLUSH request, the blocks are automatically commited
   *
   * - `Writecache/Options/AutocommitTime` - long
   *
   *     autocommit time in milliseconds. The data is automatically commited if this time passes and no FLUSH request is received
   *
   * - `Writecache/Options/Fua` - enum
   *
   *     "On" results in "fua" as argument, whereas the value "Off" results in "nofua" argument
   *
   *     * On
   *     * Off
   *
   * - `Writecache/Options/Additional` - string
   *
   *     Additional arguments passed through
   *
   * - `Cache/OpMode` - enum
   *
   *     Operation mode
   *
   *     * writeback
   *     * writethrough
   *     * passthrough
   *
   * - `Cache/MetaPool` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Name of the storage pool used for the cache metadata. If not specified, this will default to the CachePool property
   *
   * - `Cache/Metasize` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
   *
   *     Size of the cache in % (0-100) or KiB otherwise.
   *
   * - `Cache/CachePool` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
   *
   *     Name of the storage pool used for the cache cache device
   *
   * - `Cache/Cachesize` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
   *
   *     Size of the cache in % (0-100) or KiB otherwise.
   *
   * - `Cache/Blocksize` - long
   *
   *     Block size
   *
   * - `Cache/Policy` - enum
   *
   *     Replacemant policy
   *
   *     * mq
   *     * smq
   *     * cleaner
   *
   * - `StorDriver/LvcreateOptions` - regex[`.*`]
   *
   *     Additional parameters added to every 'lvcreate ... ' command
   *
   * - `StorDriver/ZfscreateOptions` - regex[`.*`]
   *
   *     Additional parameters added to every 'zfs create ... ' command
   *
   * - `StorDriver/Openflex/ApiHost` - regex[`.+`]
   *
   *     Openflex API host name
   *
   * - `StorDriver/Openflex/ApiPort` - regex[`[0-9]+`]
   *
   *     Openflex API port
   *
   * - `StorDriver/Openflex/UserName` - regex[`.+`]
   *
   *     Openflex user name
   *
   * - `StorDriver/Openflex/UserPassword` - regex[`.+`]
   *
   *     Openflex password
   *
   * - `StorDriver/Openflex/JobWaitDelay` - regex[`[0-9]+`]
   *
   *     Delay in milliseconds linstor waits between fetching the job status
   *
   * - `StorDriver/Openflex/JobWaitMaxCount` - regex[`[0-9]+`]
   *
   *     Maximum retries with wait delay until openflex fails
   *
   * - `Autoplacer/Weights/MaxFreeSpace` - regex[`^[0-9]+([.][0-9]+)?`]
   *
   *     Weight of 'MaxFreeSpace' autoplacer-strategy
   *
   * - `Autoplacer/Weights/MinReservedSpace` - regex[`^[0-9]+([.][0-9]+)?`]
   *
   *     Weight of 'MinReservedSpace' autoplacer-strategy
   *
   * - `Autoplacer/Weights/MinRscCount` - regex[`^[0-9]+([.][0-9]+)?`]
   *
   *     Weight of 'MinRscCount' autoplacer-strategy
   *
   * - `Autoplacer/Weights/MaxThroughput` - regex[`^[0-9]+([.][0-9]+)?`]
   *
   *     Weight of 'MaxThroughput' autoplacer-strategy
   *
   * - `Autoplacer/PreSelectScript` - string
   *
   *     Filename of the preselection script. File must be in /etc/linstor/selector/
   *
   * - `Autoplacer/PreSelectScriptTimeout` - long
   *
   *     Timeout in ms Linstor waits for the script to run.
   *
   * - `Autoplacer/MaxThroughput` - long
   *
   *     The maximum throughput the given storage pool is capable of.
   *
   * - `DrbdProxy/AutoEnable` - boolean_true_false
   * - `Site` - string
   * - `UpdateCacheInterval` - long
   *
   *     Interval for space cache background updates in seconds
   *
   * - `SnapshotShipping/TcpPortRange` - regex[`[0-9]+-[0-9]+`]
   *
   *     Range for allocation of snapshot shipping TCP ports
   *
   * - `DrbdOptions/Disk/on-io-error` - enum
   *     * pass_on
   *     * call-local-io-error
   *     * detach
   *
   * - `DrbdOptions/Disk/disk-barrier` - boolean
   * - `DrbdOptions/Disk/disk-flushes` - boolean
   * - `DrbdOptions/Disk/disk-drain` - boolean
   * - `DrbdOptions/Disk/md-flushes` - boolean
   * - `DrbdOptions/Disk/resync-after` - string
   * - `DrbdOptions/Disk/al-extents` - range[`67-65534`]
   * - `DrbdOptions/Disk/al-updates` - boolean
   * - `DrbdOptions/Disk/discard-zeroes-if-aligned` - boolean
   * - `DrbdOptions/Disk/disable-write-same` - boolean
   * - `DrbdOptions/Disk/disk-timeout` - range[`0-6000`]
   * - `DrbdOptions/Disk/read-balancing` - enum
   *     * prefer-local
   *     * prefer-remote
   *     * round-robin
   *     * least-pending
   *     * when-congested-remote
   *     * 32K-striping
   *     * 64K-striping
   *     * 128K-striping
   *     * 256K-striping
   *     * 512K-striping
   *     * 1M-striping
   *
   * - `DrbdOptions/Disk/rs-discard-granularity` - range[`0-1048576`]
   * - `DrbdOptions/PeerDevice/resync-rate` - range[`1-8388608`]
   * - `DrbdOptions/PeerDevice/c-plan-ahead` - range[`0-300`]
   * - `DrbdOptions/PeerDevice/c-delay-target` - range[`1-100`]
   * - `DrbdOptions/PeerDevice/c-fill-target` - range[`0-1048576`]
   * - `DrbdOptions/PeerDevice/c-max-rate` - range[`250-4194304`]
   * - `DrbdOptions/PeerDevice/c-min-rate` - range[`0-4194304`]
   * - `DrbdOptions/PeerDevice/bitmap` - boolean
   * - `DrbdOptions/Resource/cpu-mask` - string
   * - `DrbdOptions/Resource/on-no-data-accessible` - enum
   *     * io-error
   *     * suspend-io
   *
   * - `DrbdOptions/Resource/auto-promote` - boolean
   * - `DrbdOptions/Resource/peer-ack-window` - range[`2048-204800`]
   * - `DrbdOptions/Resource/peer-ack-delay` - range[`1-10000`]
   * - `DrbdOptions/Resource/twopc-timeout` - range[`50-600`]
   * - `DrbdOptions/Resource/twopc-retry-timeout` - range[`1-50`]
   * - `DrbdOptions/Resource/auto-promote-timeout` - range[`0-600`]
   * - `DrbdOptions/Resource/max-io-depth` - range[`4-4294967295`]
   * - `DrbdOptions/Resource/quorum` - enum [`1-32`]
   *     * off
   *     * majority
   *     * all
   *
   * - `DrbdOptions/Resource/on-no-quorum` - enum
   *     * io-error
   *     * suspend-io
   *
   * - `DrbdOptions/Resource/quorum-minimum-redundancy` - enum [`1-32`]
   *     * off
   *     * majority
   *     * all
   *
   * - `DrbdOptions/Net/transport` - string
   * - `DrbdOptions/Net/protocol` - enum
   *     * A
   *     * B
   *     * C
   *
   * - `DrbdOptions/Net/timeout` - range[`1-600`]
   * - `DrbdOptions/Net/max-epoch-size` - range[`1-20000`]
   * - `DrbdOptions/Net/connect-int` - range[`1-120`]
   * - `DrbdOptions/Net/ping-int` - range[`1-120`]
   * - `DrbdOptions/Net/sndbuf-size` - range[`0-10485760`]
   * - `DrbdOptions/Net/rcvbuf-size` - range[`0-10485760`]
   * - `DrbdOptions/Net/ko-count` - range[`0-200`]
   * - `DrbdOptions/Net/allow-two-primaries` - boolean
   * - `DrbdOptions/Net/cram-hmac-alg` - string
   * - `DrbdOptions/Net/shared-secret` - string
   * - `DrbdOptions/Net/after-sb-0pri` - enum
   *     * disconnect
   *     * discard-younger-primary
   *     * discard-older-primary
   *     * discard-zero-changes
   *     * discard-least-changes
   *     * discard-local
   *     * discard-remote
   *
   * - `DrbdOptions/Net/after-sb-1pri` - enum
   *     * disconnect
   *     * consensus
   *     * discard-secondary
   *     * call-pri-lost-after-sb
   *     * violently-as0p
   *
   * - `DrbdOptions/Net/after-sb-2pri` - enum
   *     * disconnect
   *     * call-pri-lost-after-sb
   *     * violently-as0p
   *
   * - `DrbdOptions/Net/always-asbp` - boolean
   * - `DrbdOptions/Net/rr-conflict` - enum
   *     * disconnect
   *     * call-pri-lost
   *     * violently
   *     * retry-connect
   *
   * - `DrbdOptions/Net/ping-timeout` - range[`1-300`]
   * - `DrbdOptions/Net/data-integrity-alg` - string
   * - `DrbdOptions/Net/tcp-cork` - boolean
   * - `DrbdOptions/Net/on-congestion` - enum
   *     * block
   *     * pull-ahead
   *     * disconnect
   *
   * - `DrbdOptions/Net/congestion-fill` - range[`0-20971520`]
   * - `DrbdOptions/Net/congestion-extents` - range[`67-65534`]
   * - `DrbdOptions/Net/csums-alg` - string
   * - `DrbdOptions/Net/csums-after-crash-only` - boolean
   * - `DrbdOptions/Net/verify-alg` - string
   * - `DrbdOptions/Net/use-rle` - boolean
   * - `DrbdOptions/Net/socket-check-timeout` - range[`0-300`]
   * - `DrbdOptions/Net/fencing` - enum
   *     * dont-care
   *     * resource-only
   *     * resource-and-stonith
   *
   * - `DrbdOptions/Net/max-buffers` - range[`32-131072`]
   * - `DrbdOptions/Net/allow-remote-read` - boolean
   * - `DrbdOptions/Handlers/after-resync-target` - string
   * - `DrbdOptions/Handlers/before-resync-target` - string
   * - `DrbdOptions/Handlers/before-resync-source` - string
   * - `DrbdOptions/Handlers/out-of-sync` - string
   * - `DrbdOptions/Handlers/quorum-lost` - string
   * - `DrbdOptions/Handlers/fence-peer` - string
   * - `DrbdOptions/Handlers/unfence-peer` - string
   * - `DrbdOptions/Handlers/initial-split-brain` - string
   * - `DrbdOptions/Handlers/local-io-error` - string
   * - `DrbdOptions/Handlers/pri-lost` - string
   * - `DrbdOptions/Handlers/pri-lost-after-sb` - string
   * - `DrbdOptions/Handlers/pri-on-incon-degr` - string
   * - `DrbdOptions/Handlers/split-brain` - string
   */
  controllerPropertyModify: {
    responses: {
      /** Controller property created/modifed. */
      201: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ControllerPropsModify'];
      };
    };
  };
  /** Delete a controller property */
  controllerPropertyDelete: {
    parameters: {
      path: {
        /** Controller property key to delete */
        key: string;
      };
    };
    responses: {
      /** property deleted */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /** Show Controller config */
  ControllerConfig: {
    responses: {
      /** Controller config */
      200: {
        content: {
          'application/json': components['schemas']['ControllerConfig'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  CtrlSetConfig: {
    responses: {
      /** Response on whether the operation was successful */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** Access denied */
      401: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ControllerConfig'];
      };
    };
  };
  /** create a h2 database backup. Currently only H2(embedded) db is working. */
  controllerBackupDB: {
    responses: {
      /** database backup created */
      201: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DatabaseBackupRequest'];
      };
    };
  };
  /** Show Controller version info */
  controllerVersion: {
    responses: {
      /** Controller version info object */
      200: {
        content: {
          'application/json': components['schemas']['ControllerVersion'];
        };
      };
    };
  };
  /**
   * Sets or modifies properties
   *
   * Possible properties are:
   * - `DrbdOptions/Proxy/memlimit` - range[`16777216-9223372036854775807`]
   * - `DrbdOptions/Proxy/read-loops` - range[`0-2147483647`]
   * - `DrbdOptions/Proxy/sndbuf-size` - range[`0-10485760`]
   * - `DrbdOptions/Proxy/rcvbuf-size` - range[`0-10485760`]
   * - `DrbdOptions/Proxy/ping-timeout` - range[`1-300`]
   * - `DrbdOptions/ProxyCompression/dict-size` - range[`4096-1610612736`]
   * - `DrbdOptions/ProxyCompression/lc` - range[`0-4`]
   * - `DrbdOptions/ProxyCompression/lp` - range[`0-4`]
   * - `DrbdOptions/ProxyCompression/pb` - range[`0-4`]
   * - `DrbdOptions/ProxyCompression/nice-len` - range[`0-273`]
   * - `DrbdOptions/ProxyCompression/mf` - enum
   *     * hc4
   *     * hc3
   *     * bt2
   *     * bt3
   *     * bt4
   *
   * - `DrbdOptions/ProxyCompression/mode` - enum
   *     * fast
   *     * normal
   *
   * - `DrbdOptions/ProxyCompression/depth` - range[`0-1000`]
   * - `DrbdOptions/ProxyCompression/level` - range[`1-9`]
   * - `DrbdOptions/ProxyCompression/contexts` - range[`1-253`]
   * - `DrbdOptions/ProxyCompression/fallback-to-zlib` - enum
   *     * off
   *     * on
   *
   * - `DrbdOptions/ProxyCompression/numa-threshold` - range[`0-253`]
   * - `DrbdOptions/ProxyCompression/level` - range[`1-9`]
   * - `DrbdOptions/ProxyCompression/level` - range[`1-22`]
   */
  resourceDrbdProxyModify: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
      };
    };
    responses: {
      /** drbd proxy properties modified */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DrbdProxyModify'];
      };
    };
  };
  /** Enables a drbd proxy on a node connection */
  resourceDrbdProxyEnable: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** source node of the connection */
        node_a: string;
        /** target node of the connection */
        node_b: string;
      };
    };
    responses: {
      /** drbd proxy configuration enabled */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DrbdProxyEnable'];
      };
    };
  };
  /** Disables a drbd proxy on a node connection */
  resourceDrbdProxyDisable: {
    parameters: {
      path: {
        /** resource to use */
        resource: string;
        /** source node of the connection */
        node_a: string;
        /** target node of the connection */
        node_b: string;
      };
    };
    responses: {
      /** drbd proxy configuration disabled */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  encryptionPassphraseModify: {
    responses: {
      /** encryption passphrase modified */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PassPhraseCreate'];
      };
    };
  };
  encryptionPassphraseCreate: {
    responses: {
      /** encryption passphrase created */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PassPhraseCreate'];
      };
    };
  };
  encryptionPassphraseEnter: {
    responses: {
      /** encryption passphrase accepted */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PassPhraseEnter'];
      };
    };
  };
  /** List all error reports */
  errorReportList: {
    parameters: {
      query: {
        /** Only show error reports of this node */
        node?: string;
        /** Unix epoch milliseconds */
        since?: number;
        /** Unix timestamp to the ending interval */
        to?: number;
        /** Include error report text in response. */
        withContent?: boolean;
        /** number of records to skip for pagination */
        offset?: number;
        /** maximum number of records to return */
        limit?: number;
      };
    };
    responses: {
      /** list of error reports */
      200: {
        content: {
          'application/json': components['schemas']['ErrorReport'][];
        };
      };
      /** Query parameter invalid. */
      404: unknown;
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /** Deletes a range of error-reports */
  errorReportDelete: {
    responses: {
      /** error-reports deleted */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ErrorReportDelete'];
      };
    };
  };
  /** Returns a error report stats object. */
  errorReportStats: {
    responses: {
      /** Object stats */
      200: {
        content: {
          'application/json': components['schemas']['ErrorReportStats'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
  };
  /** Query the specified reportid */
  errorReportShow: {
    parameters: {
      path: {
        /** Error id to select */
        reportid: string;
      };
      query: {
        /** Only show error reports of this node */
        node?: string;
        /** Unix epoch milliseconds */
        since?: number;
        /** Unix timestamp to the ending interval */
        to?: number;
        /** Include error report text in response. */
        withContent?: boolean;
        /** number of records to skip for pagination */
        offset?: number;
        /** maximum number of records to return */
        limit?: number;
      };
    };
    responses: {
      /** list of error reports */
      200: {
        content: {
          'application/json': components['schemas']['ErrorReport'][];
        };
      };
      /** Query parameter invalid. */
      404: unknown;
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /** Deletes a single error-report */
  errorReportDeleteSingle: {
    parameters: {
      path: {
        /** Error id to select */
        reportid: string;
      };
    };
    responses: {
      /** error-report deleted */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /** List all known key value store instances */
  keyValueStoresList: {
    responses: {
      /** list of key value stores */
      200: {
        content: {
          'application/json': components['schemas']['KeyValueStore'][];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /** List all known key value store instances */
  keyValueStoreList: {
    parameters: {
      path: {
        /** name of the key value store */
        instance: string;
      };
    };
    responses: {
      /** list of key value stores */
      200: {
        content: {
          'application/json': components['schemas']['KeyValueStore'][];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /** Modify a key value store */
  keyValueStoreModify: {
    parameters: {
      path: {
        /** name of the key value store */
        instance: string;
      };
    };
    responses: {
      /** key value store modified */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['KeyValueStoreModify'];
      };
    };
  };
  /** Delete a key value store */
  keyValueStoreDelete: {
    parameters: {
      path: {
        /** name of the key value store */
        instance: string;
      };
    };
    responses: {
      /** key value store deleted */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /** Query the maximum possible volume size storage pools */
  queryMaxVolumeSize: {
    responses: {
      /** list of usable storage pools */
      200: {
        content: {
          'application/json': components['schemas']['MaxVolumeSizes'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AutoSelectFilter'];
      };
    };
  };
  /** This REST-resource should be used if you want to get an overview of all resources with their volumes. */
  viewResources: {
    parameters: {
      query: {
        /** Filter only for the specified nodes, if not specified, no filtering. */
        nodes?: string[];
        /** Filter only for the specified resources, if not specified, no filtering. */
        resources?: string[];
        /** Filter only for the specified storage pools, if not specified no filtering. */
        storage_pools?: string[];
        /** filter by given properties, full property path */
        props?: string[];
        /** number of records to skip for pagination */
        offset?: number;
        /** maximum number of records to return */
        limit?: number;
      };
    };
    responses: {
      /** resources list with volume data */
      200: {
        content: {
          'application/json': components['schemas']['ResourceWithVolumes'][];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /** This REST-resource should be used if you want to get an overview of all storage pools. */
  viewStoragePools: {
    parameters: {
      query: {
        /** Filter only for the specified nodes, if not specified, no filtering. */
        nodes?: string[];
        /** Filter only for the specified storage pools, if not specified no filtering. */
        storage_pools?: string[];
        /** filter by given properties, full property path */
        props?: string[];
        /** number of records to skip for pagination */
        offset?: number;
        /** maximum number of records to return */
        limit?: number;
        /** query data from cache if available */
        cached?: boolean;
      };
    };
    responses: {
      /** storage pool list */
      200: {
        content: {
          'application/json': components['schemas']['StoragePool'][];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /** This REST-resource should be used if you want to get an overview of all snapshots. */
  viewSnapshots: {
    parameters: {
      query: {
        /** Filter only for the specified nodes, if not specified, no filtering. */
        nodes?: string[];
        /** Filter only for the specified resources, if not specified, no filtering. */
        resources?: string[];
        /** number of records to skip for pagination */
        offset?: number;
        /** maximum number of records to return */
        limit?: number;
      };
    };
    responses: {
      /** snapshot list */
      200: {
        content: {
          'application/json': components['schemas']['Snapshot'][];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  viewSnapshotShippings: {
    parameters: {
      query: {
        /** Filter only for the specified nodes, if not specified, no filtering. */
        nodes?: string[];
        /** Filter only for the specified resources, if not specified, no filtering. */
        resources?: string[];
        /** Filter only for the specified snapshots, if not specified, no filtering. */
        snapshots?: string[];
        /** Filter only for the specified status, if not specified, no filtering. */
        status?: ('running' | 'complete')[];
        /** number of records to skip for pagination */
        offset?: number;
        /** maximum number of records to return */
        limit?: number;
      };
    };
    responses: {
      /** physical storage list */
      200: {
        content: {
          'application/json': components['schemas']['SnapshotShippingStatus'][];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /** Returns a resource stats object. */
  resourcesStats: {
    responses: {
      /** Object stats */
      200: {
        content: {
          'application/json': components['schemas']['ResourceStats'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
  };
  /** Returns a storage pool stats object. */
  storagePoolsStats: {
    responses: {
      /** Object stats */
      200: {
        content: {
          'application/json': components['schemas']['StoragePoolStats'];
        };
      };
      /** invalid input, or request failed */
      400: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
  };
  /** Gives a grouped list of physical storage that can be turned into a LINSTOR storage-pool */
  viewPhysicaStorage: {
    parameters: {
      query: {
        /** number of records to skip for pagination */
        offset?: number;
        /** maximum number of records to return */
        limit?: number;
      };
    };
    responses: {
      /** physical storage list */
      200: {
        content: {
          'application/json': components['schemas']['PhysicalStorage'][];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /** Gives a complete list of physical storage that can be turned into a LINSTOR storage-pool. */
  getPhysicalStorage: {
    parameters: {
      path: {
        /** node to use */
        node: string;
      };
    };
    responses: {
      /** physical storage list */
      200: {
        content: {
          'application/json': components['schemas']['PhysicalStorageNode'][];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /**
   * Creates a LVM/LVM-thin, ZFS pool on the given device and if supported VDO(optional) under it.
   * logcal_size_kib parameter is only needed if LVM-thin or vdo is used.
   * Also note VDO can only used with LVM-fat.
   */
  createDevicePool: {
    parameters: {
      path: {
        /** node to use */
        node: string;
      };
    };
    responses: {
      /** device pool created */
      201: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PhysicalStorageCreate'];
      };
    };
  };
  createSOSReport: {
    parameters: {
      query: {
        /** nodes to use */
        nodes?: string[];
        /** use nodes where any given rsc is deployed */
        rscs?: string[];
        /** do not use the given nodes */
        exclude?: string[];
        /** include logs from ctrl */
        'include-ctrl'?: boolean;
        /** Unix epoch milliseconds */
        since?: number;
      };
    };
    responses: {
      /** SOS report created. */
      201: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  downloadSOSReport: {
    parameters: {
      query: {
        /** nodes to use */
        nodes?: string[];
        /** use nodes where any given rsc is deployed */
        rscs?: string[];
        /** do not use the given nodes */
        exclude?: string[];
        /** include logs from ctrl */
        'include-ctrl'?: boolean;
        /** Unix epoch milliseconds */
        since?: number;
      };
    };
    responses: {
      /** SOS report ready to download as binary octet stream .tar.gz */
      200: {
        content: {
          'application/octet-stream': string;
        };
      };
      /** operation failed */
      500: {
        content: {
          'application/json': components['schemas']['ApiCallRc'];
        };
      };
    };
  };
  /** Sets or modifies default username / password for EXOS enclosures */
  exosModifyDefault: {
    responses: {
      /** default configuration modified */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ExosDefaultsModify'];
      };
    };
  };
  /** Creates a new enclosure unless it already exists */
  exosCreate: {
    responses: {
      /** Enclosure successfully created */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ExosEnclosure'];
      };
    };
  };
  /** Modifies an existing enclosure */
  exosModify: {
    parameters: {
      path: {
        /** Name of the enclosure */
        enclosure: string;
      };
    };
    responses: {
      /** Enclosure successfully modified */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ExosEnclosure'];
      };
    };
  };
  /** Deletes an existing enclosure */
  exosDelete: {
    parameters: {
      path: {
        /** Name of the enclosure */
        enclosure: string;
      };
    };
    responses: {
      /** Enclosure successfully deleted */
      200: {
        content: {
          'application/json': components['schemas']['ApiCallRcList'];
        };
      };
    };
  };
  /** Lists the most current X events */
  exosDescribe: {
    parameters: {
      path: {
        /** Name of the enclosure */
        enclosure: string;
      };
      query: {
        /** Number of events to fetch */
        count?: number;
      };
    };
    responses: {
      /** List of EXOS events */
      200: {
        content: {
          'application/json': components['schemas']['ExosEnclosureEvent'][];
        };
      };
    };
  };
  /** Lists the connection-mesh of EXOS Ports to Linstor Nodes */
  exosMap: {
    responses: {
      /** List of EXOS events */
      200: {
        content: {
          'application/json': components['schemas']['ExosConnectionMap'][];
        };
      };
    };
  };
}

export interface external {}
